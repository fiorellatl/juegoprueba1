<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Capybara Dash - Juego</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Usa min-height para asegurar que ocupe toda la altura */
            width: 100vw; /* Asegura que ocupe todo el ancho del viewport */
            background: #f0f0f0;
            font-family: 'Inter', Arial, sans-serif;
            overflow: hidden; /* Evita el scroll en el body */
        }
        #gameContainer {
            position: relative;
            width: 100%;
            max-width: 800px; /* Limita el ancho máximo para pantallas grandes */
            aspect-ratio: 2 / 1; /* Mantiene la proporción 800x400 (2:1) */
            background: linear-gradient(to bottom, #87CEEB, #a8e4a0);
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0,0,0,0.4);
            overflow: hidden; /* Asegura que el contenido del canvas no se desborde */
            display: flex; /* Para centrar el canvas dentro del contenedor */
            justify-content: center;
            align-items: center;
        }
        #gameCanvas {
            display: block;
            /* El ancho y alto del canvas se establecerán en JavaScript para el buffer de dibujo */
            /* Las dimensiones CSS se ajustarán dinámicamente en resizeGame() */
        }
        /* Estilos para los menús y botones */
        #menu, #pauseMenu, #levelSelect, #characterMenu, #levelComplete {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 20px; /* Ajustado para pantallas más pequeñas */
            border-radius: 15px;
            text-align: center;
            display: none;
            box-shadow: 0 0 20px rgba(0,0,0,0.4);
            border: 2px solid #4CAF50;
            max-width: 90%; /* Limita el ancho en móviles */
            box-sizing: border-box; /* Incluye padding y border en el ancho */
            z-index: 5; /* Asegura que los menús estén por encima del canvas */
            max-height: 90%; /* Limita la altura máxima del menú */
            overflow-y: auto; /* Permite el scroll vertical si el contenido excede la altura */
        }
        /* Estilos para la nueva pantalla de inicio */
        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* background: rgba(0,0,0,0.7); -- Este fondo ahora se dibuja en el canvas */
            color: white;
            display: flex; /* Mostrar por defecto al inicio */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10; /* Asegura que la pantalla de inicio esté en la parte superior */
        }
        #startScreen h1 {
            font-family: 'Press Start 2P', cursive;
            font-size: clamp(2em, 8vw, 4em); /* Tamaño de fuente responsivo para el título */
            color: #FFD700; /* Color dorado para el título */
            text-shadow: 4px 4px #000; /* Efecto de sombra pixelado */
            margin-bottom: 0.5em;
            text-align: center; /* Centrar el título */
        }
        #startScreen p {
            font-family: 'Press Start 2P', cursive;
            font-size: clamp(0.7em, 1.8vw, 0.9em); /* Tamaño de fuente responsivo para el texto, un poco más pequeño */
            color: #FFF;
            margin-top: 0;
            line-height: 1.5;
            padding: 0 10px; /* Pequeño padding para evitar que el texto se pegue a los bordes */
            text-align: center; /* Centrar el texto */
        }
        #startScreen button {
            margin-top: 20px;
        }

        h2 {
            color: #333;
            margin-top: 0;
            font-size: clamp(1.5em, 5vw, 2.5em); /* Fuente responsiva */
        }
        button {
            padding: 1.5vh 3vw; /* Padding responsivo */
            margin: 1.5vh 1vw; /* Margen responsivo */
            cursor: pointer;
            background: linear-gradient(to bottom, #4CAF50, #45a049);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: clamp(1em, 3.5vw, 1.2em); /* Fuente responsiva */
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            min-width: 150px; /* Ancho mínimo para botones */
            max-width: 250px; /* Ancho máximo para los botones */
            width: calc(100% - 2vw); /* Ocupa casi todo el ancho disponible */
        }
        button:hover {
            background: linear-gradient(to bottom, #45a049, #3e8e41);
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0,0,0,0.3);
        }
        button:active {
            transform: translateY(1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        button:disabled {
            background: #cccccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        #coinDisplay, #coinDisplayPause, #coinDisplayLevel, #coinDisplayCharacter {
            font-weight: bold;
            font-size: 1.1em; /* Ajustado para pantallas más pequeñas */
            color: #555;
            transition: color 0.5s;
        }
        .highlight {
            color: #FFD700;
            text-shadow: 0 0 5px rgba(255,215,0,0.7);
        }
        #levelComplete h2 {
            font-size: 24px; /* Ajustado */
            color: #4CAF50;
        }
        #levelComplete p {
            font-size: 18px; /* Ajustado */
            color: #333;
        }
        #levelList, #characterList {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px; /* Espacio entre elementos */
            margin-bottom: 15px; /* Mantener un margen para el botón de volver */
            padding-bottom: 10px; /* Añadir padding inferior para evitar que el contenido se pegue al borde */
            overflow-y: auto; /* Permitir scroll dentro de la lista de personajes si es necesario */
            max-height: calc(100vh - 200px); /* Ajustar max-height para dejar espacio al título y botón. Ajustar según sea necesario */
        }
        .character-option {
            display: flex; /* Usar flexbox para el layout interno */
            flex-direction: column; /* Apilar elementos verticalmente */
            align-items: center; /* Centrar horizontalmente */
            margin: 10px; /* Ajustado */
            padding: 8px; /* Ajustado */
            border: 2px solid #ccc;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            width: 120px; /* Ancho fijo para las opciones de personaje */
            box-sizing: border-box;
        }
        .character-option.selected {
            border-color: #4CAF50;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
            background-color: #e6ffe6;
        }
        .character-option:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 10px rgba(0,0,0,0.2);
        }
        .character-option img, .character-option .character-color-box {
            width: 50px; /* Ajustado */
            height: 50px; /* Ajustado */
            border-radius: 5px;
            margin-bottom: 5px;
        }
        .character-option p {
            margin: 0;
            font-weight: bold;
            color: #333;
            font-size: 0.9em; /* Ajustado */
        }
        .character-option .cost {
            font-size: 0.8em; /* Ajustado */
            color: #777;
        }
        .character-option button {
            margin-top: 8px; /* Ajustado */
            padding: 6px 12px; /* Ajustado */
            font-size: 12px; /* Ajustado */
            width: auto; /* Ancho automático para botones dentro de opciones */
            max-width: none; /* Elimina el max-width */
        }

        #pauseButton {
            position: absolute;
            top: 10px; /* Ajustado */
            right: 10px; /* Posicionado a la derecha */
            width: 35px; /* Ajustado */
            height: 35px; /* Ajustado */
            background: #FF0000;
            border-radius: 50%;
            cursor: pointer;
            display: none;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            transition: background 0.3s ease;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px; /* Ajustado */
            color: white;
            font-weight: bold;
            z-index: 10; /* Asegura que esté por encima del canvas */
        }
        #pauseButton:hover {
            background: #CC0000;
        }
        #errorMessage {
            position: absolute;
            top: 10px; /* Ajustado */
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 0, 0, 0.9);
            color: white;
            padding: 8px 15px; /* Ajustado */
            border-radius: 8px;
            display: none;
            box-shadow: 0 0 10px rgba(255,0,0,0.5);
            font-weight: bold;
            font-size: 0.9em; /* Ajustado */
            z-index: 10;
        }

        /* Media Queries para ajustes finos en diferentes tamaños de pantalla */
        @media (max-width: 600px) {
            h2 {
                font-size: 1.5em;
            }
            button {
                padding: 8px 15px;
                font-size: 14px;
            }
            .level-preview {
                width: 80px;
                height: 50px;
                margin: 5px;
                font-size: 0.8em;
            }
            .character-option {
                width: 100px;
                margin: 5px;
            }
            .character-option img, .character-option .character-color-box {
                width: 40px;
                height: 40px;
            }
            .character-option p {
                font-size: 0.8em;
            }
            .character-option button {
                font-size: 11px;
                padding: 5px 10px;
            }
            #pauseButton {
                width: 30px;
                height: 30px;
                font-size: 18px;
            }
            #errorMessage {
                padding: 6px 12px;
                font-size: 0.8em;
            }
            /* Ajustes específicos para el menú de personajes en pantallas pequeñas */
            #characterMenu {
                padding: 10px; /* Reducir el padding general del menú */
            }
            #characterList {
                max-height: calc(100vh - 180px); /* Ajustar el max-height para dejar más espacio */
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>

        <div id="startScreen">
            <h1>Capybara Dash</h1>
            <p>Este juego fue creado por Esteban, Cristóbal y Fiore. Ojalá no mueras</p>
            <button onclick="showMainMenuFromStartScreen()">Empezar</button>
        </div>

        <div id="menu">
            <h2>Capybara Dash</h2>
            <button onclick="startGame(1)">Jugar</button>
            <button onclick="showLevelSelect()">Seleccionar Nivel</button>
            <button onclick="showCharacters()">Seleccionar Personaje</button>
            <button onclick="togglePractice()">Modo Práctica</button>
            <p>Monedas: <span id="coinDisplay">0</span></p>
        </div>

        <div id="levelSelect">
            <h2>Seleccionar Nivel</h2>
            <div id="levelList"></div>
            <button onclick="returnToMenu()">Volver</button>
            <p>Monedas: <span id="coinDisplayLevel">0</span></p>
        </div>

        <div id="pauseMenu">
            <h2>Pausado</h2>
            <button onclick="resumeGame()">Reanudar</button>
            <button onclick="togglePractice()">Modo Práctica</button>
            <button onclick="showCharacters()">Seleccionar Personaje</button>
            <button onclick="returnToMenu()">Menú Principal</button>
            <p>Monedas: <span id="coinDisplayPause">0</span></p>
        </div>

        <div id="characterMenu">
            <h2>Seleccionar Personaje</h2>
            <div id="characterList"></div>
            <button onclick="returnToMenu()">Volver</button>
            <p>Monedas: <span id="coinDisplayCharacter">0</span></p>
        </div>

        <div id="levelComplete">
            <h2>¡Buena, Capybara! ¡Lo lograste!</h2>
            <p id="completionTime"></p>
            <button onclick="returnToMenu()">Menú Principal</button>
        </div>

        <div id="pauseButton" onclick="togglePause()">II</div>

        <div id="errorMessage"></div>
    </div>

    <script>
        // --- Global Variables and DOM Elements ---
        const gameContainer = document.getElementById('gameContainer');
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('startScreen'); // Nueva referencia a la pantalla de inicio
        const menu = document.getElementById('menu');
        const levelSelect = document.getElementById('levelSelect');
        const pauseMenu = document.getElementById('pauseMenu');
        const characterMenu = document.getElementById('characterMenu');
        const levelComplete = document.getElementById('levelComplete');
        const pauseButton = document.getElementById('pauseButton');
        const errorMessage = document.getElementById('errorMessage');

        // Dimensiones base del canvas para la lógica del juego
        const BASE_CANVAS_WIDTH = 800;
        const BASE_CANVAS_HEIGHT = 400;

        // Player coins, loaded from localStorage or initialized to 0
        let coins = localStorage.getItem('coins') ? parseInt(localStorage.getItem('coins')) : 0;
        const coinDisplays = [
            document.getElementById('coinDisplay'),
            document.getElementById('coinDisplayPause'),
            document.getElementById('coinDisplayLevel'),
            document.getElementById('coinDisplayCharacter')
        ];
        // Update coin display in all locations
        coinDisplays.forEach(display => display.textContent = coins);

        // Character definitions
        const characters = [
            { name: 'Capybara', cost: 0, color: '#FFFFFF', unlocked: true, isImage: true, imageUrl: 'capybara.png' },
            { name: 'Poop', cost: 100, color: '#8B4513', unlocked: false, isImage: true, imageUrl: 'poop.png' },
            { name: 'SúperDX123', cost: 200, color: '#FFA500', unlocked: false, isImage: true, imageUrl: 'esteban.png' },
            { name: 'lushli', cost: 300, color: '#000000', unlocked: false, isImage: true, imageUrl: 'kily.png' },
            { name: 'Dragon', cost: 400, color: '#8A2BE2', unlocked: false, isImage: true, imageUrl: 'eyc.png' }
        ];
        let currentCharacter = characters[0]; // Initial character
        // Load unlocked characters from localStorage
        const savedCharacters = localStorage.getItem('characters') ? JSON.parse(localStorage.getItem('characters')) : ['Capybara'];
        characters.forEach(char => {
            // Update saved character names if they were the old ones
            if (char.name === 'SúperDX123' && savedCharacters.includes('Lion')) {
                char.unlocked = true;
            } else if (char.name === 'lushli' && savedCharacters.includes('Penguin')) {
                char.unlocked = true;
            } else if (savedCharacters.includes(char.name)) {
                char.unlocked = true;
            }
        });

        // --- Audio Configuration (Web Audio API) ---
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let audioBuffer = null; // Buffer for background music (TNT.mp3)
        let audioSource = null; // Current audio source for background music
        let audioStartTime = 0; // Time when music started
        let deathSoundBuffer = null; // Buffer for death sound
        let audioTimeoutId = null; // To store the setTimeout ID for stopping music

        // Asset paths
        const audioUrl = 'TNT.mp3';
        const deathSoundUrl = 'https://www.myinstants.com/media/sounds/8bit_explosion.mp3';
        const capybaraImageUrl = 'capybara.png';
        const poopImageUrl = 'poop.png';
        const cheeseImageUrl = 'cheese.png';
        const eycImageUrl = 'eyc.png';
        const estebanImageUrl = 'esteban.png';
        const kilyImageUrl = 'kily.png';
        const woolImageUrl = 'wool.png';
        const fenceImageUrl = 'fence.png';
        const lowFenceImageUrl = 'lowfence.webp'; // Added low fence image URL
        const spikeImageUrl = 'spike.png';
        const bladeImageUrl = 'blade.png';


        // Image buffers
        let capybaraImage = null;
        let poopImage = null;
        let cheeseImage = null;
        let eycImage = null;
        let estebanImage = null;
        let kilyImage = null;
        let woolImage = null;
        let fenceImage = null;
        let lowFenceImage = null; // Declared low fence image variable
        let spikeImage = null;
        let bladeImage = null;


        // --- Game Variables ---
        let particles = []; // Particles for visual effects
        let gameRunning = false;
        let isPaused = false;
        let currentLevel = 1;
        let practiceMode = false;
        let practiceStartTime = 0;
        let gameStartTime = 0;

        // Cloud variables
        let clouds = [];
        let lastCloudSpawnTime = 0;
        const cloudSpawnInterval = 3000;

        // Player object (coordenadas en el sistema de 800x400)
        const player = {
            x: 100,
            y: 300,
            vy: 0,
            jumping: false,
            jumpHoldTime: 0,
            maxJumpHold: 500,
            width: 45,
            height: 45
        };
        const gravity = 0.8;
        const jumpStrength = -12;
        let scrollPosition = 0;
        let scrollSpeed = 0;
        let objects = [];
        let terrain = [];

        // Global object ID counter
        let objectIdCounter = 0;

        // Objetos para la pantalla de inicio (caen desde arriba)
        let startScreenObjects = [];
        let startScreenAnimationId = null; // Para controlar la animación de la pantalla de inicio

        // Helper function to create game objects with unique IDs
        function createGameObject(type, x, y, width, height, moving = null) {
            return { id: objectIdCounter++, type, position: { x, y }, width, height, moving };
        }

        // --- Asset Loading Functions ---

        /**
         * Loads an audio file using Web Audio API.
         * @param {string} url - The URL of the audio file.
         * @returns {Promise<AudioBuffer|null>} A promise that resolves with the AudioBuffer or null on failure.
         */
        async function loadAudio(url) {
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Audio fetch failed: ${response.status} for ${url}`);
                const arrayBuffer = await response.arrayBuffer();
                return await audioContext.decodeAudioData(arrayBuffer);
            } catch (error) {
                console.error('Error loading audio:', error);
                return null;
            }
        }

        /**
         * Loads an image.
         * @param {string} url - The URL of the image.
         * @returns {Promise<HTMLImageElement>} A promise that resolves with the loaded image.
         */
        function loadImage(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = () => {
                    console.warn(`Failed to load image: ${url}. Using placeholder.`);
                    // Fallback to a placeholder if the image fails to load
                    img.src = `https://placehold.co/${player.width}x${player.height}/cccccc/000000?text=Error`;
                    resolve(img); // Resolve even on error to continue game loading
                };
                img.src = url;
            });
        }

        /**
         * Loads all game assets (audio and images).
         */
        async function loadAssets() {
            console.log('Cargando assets...');
            try {
                // Load audio
                audioBuffer = await loadAudio(audioUrl);
                deathSoundBuffer = await loadAudio(deathSoundUrl);

                // Load images
                capybaraImage = await loadImage(capybaraImageUrl);
                poopImage = await loadImage(poopImageUrl);
                cheeseImage = await loadImage(cheeseImageUrl);
                eycImage = await loadImage(eycImageUrl);
                estebanImage = await loadImage(estebanImageUrl);
                kilyImage = await loadImage(kilyImageUrl);
                woolImage = await loadImage(woolImageUrl);
                fenceImage = await loadImage(fenceImageUrl);
                lowFenceImage = await loadImage(lowFenceImageUrl); // Load low fence image
                spikeImage = await loadImage(spikeImageUrl);
                bladeImage = await loadImage(bladeImageUrl);


                console.log('Assets cargados exitosamente');
            } catch (error) {
                console.error('Fallo al cargar assets:', error);
                showError('Error al cargar assets. Revisa la consola y asegúrate de que las URLs de los assets sean correctas y accesibles.');
            }
            // Después de cargar los assets, inicializa la pantalla de inicio
            initStartScreen();
            animateStartScreen();
        }

        /**
         * Displays a temporary error message on the screen.
         * @param {string} msg - The error message to display.
         */
        function showError(msg) {
            errorMessage.textContent = msg;
            errorMessage.style.display = 'block';
            setTimeout(() => errorMessage.style.display = 'none', 5000);
        }

        // --- Audio Control Functions ---

        /**
         * Plays a given AudioBuffer.
         * @param {AudioBuffer} buffer - The audio buffer to play.
         * @returns {AudioBufferSourceNode|null} The created audio source, or null if no buffer.
         */
        function playAudio(buffer) {
            if (buffer) {
                const source = audioContext.createBufferSource();
                source.buffer = buffer;
                source.connect(audioContext.destination);
                source.start(0);
                return source;
            }
            return null;
        }

        /**
         * Stops the current background music.
         */
        function stopAudio() {
            if (audioSource) {
                audioSource.stop();
                audioSource = null;
            }
            if (audioTimeoutId) {
                clearTimeout(audioTimeoutId);
                audioTimeoutId = null;
            }
        }

        // --- Particle Functions ---

        /**
         * Creates particles at a specific position with a given color.
         * @param {number} x - X coordinate.
         * @param {number} y - Y coordinate.
         * @param {number} count - Number of particles to create.
         * @param {string} color - Color of the particles (e.g., '#FFFFFF').
         */
        function createParticles(x, y, count, color) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x,
                    y,
                    vx: (Math.random() - 0.5) * 5,
                    vy: (Math.random() - 0.5) * 5,
                    size: 10,
                    alpha: 1,
                    color,
                    life: 0.5
                });
            }
        }

        // --- Cloud Functions ---

        /**
         * Creates a new cloud object.
         */
        function createCloud() {
            const size = 50 + Math.random() * 50;
            clouds.push({
                x: BASE_CANVAS_WIDTH, // Usar dimensiones base
                y: Math.random() * (BASE_CANVAS_HEIGHT / 3), // Usar dimensiones base
                size: size,
                speed: 0.5 + Math.random() * 0.5,
                alpha: 0.8 + Math.random() * 0.2
            });
        }

        /**
         * Draws all clouds on the canvas.
         */
        function drawClouds() {
            clouds.forEach(cloud => {
                ctx.fillStyle = `rgba(255, 255, 255, ${cloud.alpha})`;
                ctx.beginPath();
                ctx.arc(cloud.x, cloud.y, cloud.size * 0.6, 0, Math.PI * 2);
                ctx.arc(cloud.x + cloud.size * 0.8, cloud.y, cloud.size * 0.5, 0, Math.PI * 2);
                ctx.arc(cloud.x + cloud.size * 0.4, cloud.y + cloud.size * 0.3, cloud.size * 0.7, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        /**
         * Updates cloud positions and manages their lifecycle.
         */
        function updateClouds(timestamp) {
            // Spawn new clouds
            if (timestamp - lastCloudSpawnTime > cloudSpawnInterval) {
                createCloud();
                lastCloudSpawnTime = timestamp;
            }

            // Move and filter clouds
            clouds = clouds.filter(cloud => {
                cloud.x -= cloud.speed;
                return cloud.x + cloud.size > 0;
            });
        }

        // --- Level Generation and Definition ---

        /**
         * Generates level objects based on a template.
         * This function now primarily adds the 'finish' object and ensures IDs are assigned.
         * @param {Array<Object>} baseObjects - Array of base objects (world coordinates).
         * @param {number} scrollSpeed - Level scroll speed.
         * @param {number} duration - Estimated level duration in seconds.
         * @returns {Array<Object>} Array of level objects with assigned IDs.
         */
        function generateLevelObjects(baseObjects, scrollSpeed, duration = 45) {
            // Deep copy base objects and assign IDs if not already present
            const objectsWithIds = baseObjects.map(obj => ({
                ...obj,
                id: obj.id !== undefined ? obj.id : objectIdCounter++,
                position: { ...obj.position }
            }));
            // Add 'finish' object at the end of the level
            const finishX = (duration * scrollSpeed * 60) + BASE_CANVAS_WIDTH; // Usar BASE_CANVAS_WIDTH
            objectsWithIds.push(createGameObject('finish', finishX, 300, 40, 100));
            return objectsWithIds;
        }

        /**
         * Generates level terrain based on a template and repeats it to cover the duration.
         * @param {Array<Object>} baseTerrain - Array of base terrain segments.
         * @param {number} scrollSpeed - Level scroll speed.
         * @param {number} duration - Estimated level duration in seconds.
         * @returns {Array<Object>} Array of generated terrain segments.
         */
        function generateTerrain(baseTerrain, scrollSpeed, duration = 45) {
            // Calculate the width of one terrain cycle
            const cycleWidth = baseTerrain[baseTerrain.length - 1].x + baseTerrain[baseTerrain.length - 1].width;
            // Calculate the total width required for the level
            const requiredWidth = duration * scrollSpeed * 60;
            // Calculate how many terrain cycles are needed
            const cycles = Math.ceil(requiredWidth / cycleWidth) + 1;
            const terrain = [];
            for (let i = 0; i < cycles; i++) {
                baseTerrain.forEach(seg => {
                    terrain.push({ ...seg, x: seg.x + i * cycleWidth });
                });
            }
            return terrain;
        }

        const initialDelayX = 2.5 * 12 * 60; // 2.5 seconds * max scrollSpeed (12) * 60 frames/sec

        // Level definitions
        const levels = {
            1: {
                name: 'Facilito',
                scrollSpeed: (16.8 * 0.85) * 1.15, /* Reduced by 15% and then increased by 15% */
                practicePoints: [0, 10, 20, 30, 40],
                previewColor: '#00FF00',
                baseObjects: [
                    createGameObject('fence', initialDelayX + 300, 270, 80, 80), // Doubled size, adjusted Y
                    createGameObject('wool', initialDelayX + 450, 180, 60, 60), // Doubled size, appeared in sky
                    createGameObject('low_fence', initialDelayX + 600, 290, 40, 60), /* Adjusted size and Y */
                    createGameObject('spike', initialDelayX + 780, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 880, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('blade', initialDelayX + 1000, 180, 30, 30, { type: 'vertical', range: 40, speed: 1.5 }),
                    createGameObject('wool', initialDelayX + 1150, 120, 60, 60), // Doubled size
                    createGameObject('fence', initialDelayX + 1500, 270, 80, 80), // Doubled size, adjusted Y
                    createGameObject('spike', initialDelayX + 1650, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 1800, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('wool', initialDelayX + 1950, 180, 60, 60), // Doubled size, appeared in sky
                    createGameObject('low_fence', initialDelayX + 2100, 290, 40, 60), /* Adjusted size and Y */
                    createGameObject('blade', initialDelayX + 2250, 320, 30, 30, { type: 'horizontal', range: 50, speed: 2 }),
                    createGameObject('spring', initialDelayX + 2400, 330, 30, 20),
                    createGameObject('fence', initialDelayX + 2550, 270, 80, 80), // Doubled size, adjusted Y
                    createGameObject('spike', initialDelayX + 2700, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 2850, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('wool', initialDelayX + 3000, 180, 60, 60), // Doubled size, appeared in sky
                    createGameObject('low_fence', initialDelayX + 3150, 290, 40, 60), /* Adjusted size and Y */
                    createGameObject('blade', initialDelayX + 3300, 260, 30, 30, { type: 'vertical', range: 40, speed: 1.5 }),
                    createGameObject('spring', initialDelayX + 3450, 330, 30, 20),
                    createGameObject('fence', initialDelayX + 3600, 270, 80, 80), // Doubled size, adjusted Y
                    createGameObject('spike', initialDelayX + 3750, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 3900, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('wool', initialDelayX + 4050, 180, 60, 60), // Doubled size, appeared in sky
                    createGameObject('low_fence', initialDelayX + 4200, 290, 40, 60), /* Adjusted size and Y */
                    createGameObject('blade', initialDelayX + 4350, 320, 30, 30, { type: 'horizontal', range: 60, speed: 3 }),
                    createGameObject('spring', initialDelayX + 4500, 330, 30, 20),
                    createGameObject('fence', initialDelayX + 4650, 270, 80, 80), // Doubled size, adjusted Y
                    createGameObject('spike', initialDelayX + 4800, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 4950, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('wool', initialDelayX + 5100, 180, 60, 60), // Doubled size, appeared in sky
                    createGameObject('low_fence', initialDelayX + 5250, 290, 40, 60), /* Adjusted size and Y */
                    createGameObject('blade', initialDelayX + 5400, 260, 30, 30, { type: 'vertical', range: 50, speed: 2.5 }),
                    createGameObject('spring', initialDelayX + 5550, 330, 30, 20),
                    createGameObject('fence', initialDelayX + 5700, 270, 80, 80), // Doubled size, adjusted Y
                    createGameObject('spike', initialDelayX + 5850, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 6000, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('wool', initialDelayX + 6150, 180, 60, 60), // Doubled size, appeared in sky
                    createGameObject('low_fence', initialDelayX + 6300, 290, 40, 60), /* Adjusted size and Y */
                    createGameObject('blade', initialDelayX + 6450, 320, 30, 30, { type: 'horizontal', range: 70, speed: 3.5 }),
                    createGameObject('spring', initialDelayX + 6600, 330, 30, 20),
                    createGameObject('fence', initialDelayX + 6750, 270, 80, 80), // Doubled size, adjusted Y
                    createGameObject('spike', initialDelayX + 6900, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 7050, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('wool', initialDelayX + 7200, 180, 60, 60), // Doubled size, appeared in sky
                    createGameObject('low_fence', initialDelayX + 7350, 290, 40, 60), /* Adjusted size and Y */
                    createGameObject('blade', initialDelayX + 7500, 260, 30, 30, { type: 'vertical', range: 60, speed: 3 }),
                    createGameObject('spring', initialDelayX + 7650, 330, 30, 20),
                    createGameObject('fence', initialDelayX + 7800, 270, 80, 80), // Doubled size, adjusted Y
                    createGameObject('spike', initialDelayX + 7950, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 8100, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('wool', initialDelayX + 8250, 180, 60, 60), // Doubled size, appeared in sky
                    createGameObject('low_fence', initialDelayX + 8400, 290, 40, 60), /* Adjusted size and Y */
                    createGameObject('blade', initialDelayX + 8550, 320, 30, 30, { type: 'horizontal', range: 80, speed: 4 }),
                    createGameObject('spring', initialDelayX + 8700, 330, 30, 20),
                    createGameObject('fence', initialDelayX + 8850, 270, 80, 80), // Doubled size, adjusted Y
                    createGameObject('spike', initialDelayX + 9000, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 9150, 260, 90, 90), // 3x bigger, adjusted Y

                    // New obstacles added for Level 1 (between 15s and 40s mark)
                    createGameObject('spike', initialDelayX + 10500, 330, 30, 20),
                    createGameObject('low_fence', initialDelayX + 11500, 290, 40, 60),
                    createGameObject('spike', initialDelayX + 12500, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 13500, 260, 90, 90),
                    createGameObject('low_fence', initialDelayX + 14500, 290, 40, 60),
                    createGameObject('blade', initialDelayX + 15500, 180, 30, 30, { type: 'vertical', range: 40, speed: 1.5 }),
                    createGameObject('spike', initialDelayX + 16500, 330, 30, 20),
                    createGameObject('wool', initialDelayX + 17500, 120, 60, 60),
                    createGameObject('low_fence', initialDelayX + 18500, 290, 40, 60),
                    createGameObject('spike', initialDelayX + 19500, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 20500, 260, 90, 90),
                    createGameObject('blade', initialDelayX + 21500, 320, 30, 30, { type: 'horizontal', range: 50, speed: 2 }),
                    createGameObject('low_fence', initialDelayX + 22500, 290, 40, 60),
                    createGameObject('spike', initialDelayX + 23500, 330, 30, 20),
                    createGameObject('wool', initialDelayX + 24500, 180, 60, 60),
                    createGameObject('low_fence', initialDelayX + 25500, 290, 40, 60),
                    createGameObject('spike', initialDelayX + 26500, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 27500, 260, 90, 90),
                    createGameObject('blade', initialDelayX + 28500, 260, 30, 30, { type: 'vertical', range: 40, speed: 1.5 }),
                    createGameObject('low_fence', initialDelayX + 29500, 290, 40, 60),
                    createGameObject('spike', initialDelayX + 30500, 330, 30, 20),
                    createGameObject('wool', initialDelayX + 31500, 180, 60, 60),
                    createGameObject('low_fence', initialDelayX + 32500, 290, 40, 60),
                    createGameObject('spike', initialDelayX + 33500, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 34500, 260, 90, 90)
                ],
                baseTerrain: [
                    { x: 0, y: 350, width: initialDelayX + 200, height: 50 }, // Starting platform
                    { x: initialDelayX + 250, y: 320, width: 100, height: 50 },
                    { x: initialDelayX + 400, y: 290, width: 100, height: 50 },
                    { x: initialDelayX + 550, y: 350, width: 200, height: 50 },
                    { x: initialDelayX + 700, y: 300, width: 80, height: 50 },
                    { x: initialDelayX + 830, y: 250, width: 80, height: 50 },
                    { x: initialDelayX + 960, y: 200, width: 80, height: 50 },
                    { x: initialDelayX + 1090, y: 150, width: 80, height: 50 },
                    { x: initialDelayX + 1300, y: 290, width: 100, height: 50 },
                    { x: initialDelayX + 1450, y: 350, width: 200, height: 50 },
                    { x: initialDelayX + 1700, y: 320, width: 150, height: 50 },
                    { x: initialDelayX + 1900, y: 290, width: 100, height: 50 },
                    { x: initialDelayX + 2100, y: 350, width: 200, height: 50 },
                    { x: initialDelayX + 2450, y: 290, width: 100, height: 50 },
                    { x: initialDelayX + 2600, y: 350, width: 300, height: 50 },
                    { x: initialDelayX + 2950, y: 320, width: 200, height: 50 },
                    { x: initialDelayX + 3200, y: 290, width: 150, height: 50 },
                    { x: initialDelayX + 3400, y: 350, width: 400, height: 50 },
                    { x: initialDelayX + 3850, y: 320, width: 250, height: 50 },
                    { x: initialDelayX + 4150, y: 290, width: 200, height: 50 },
                    { x: initialDelayX + 4400, y: 350, width: 500, height: 50 },
                    { x: initialDelayX + 4950, y: 320, width: 300, height: 50 },
                    { x: initialDelayX + 5300, y: 290, width: 250, height: 50 },
                    { x: initialDelayX + 5600, y: 350, width: 600, height: 50 },
                    { x: initialDelayX + 6250, y: 320, width: 350, height: 50 },
                    { x: initialDelayX + 6650, y: 290, width: 300, height: 50 },
                    { x: initialDelayX + 7000, y: 350, width: 700, height: 50 },
                    { x: initialDelayX + 7750, y: 320, width: 400, height: 50 },
                    { x: initialDelayX + 8200, y: 290, width: 350, height: 50 },
                    { x: initialDelayX + 8600, y: 350, width: 800, height: 50 },
                    { x: initialDelayX + 9450, y: 320, width: 500, height: 50 },
                    { x: initialDelayX + 10000, y: 290, width: 450, height: 50 }
                ]
            },
            2: {
                name: 'Ataque de Queso',
                scrollSpeed: 21 * 0.85, /* Reduced by 15% */
                practicePoints: [0, 10, 20, 30, 40],
                previewColor: '#FFD700',
                baseObjects: [
                    createGameObject('cheese', initialDelayX + 700, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 750, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 800, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 850, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 900, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 950, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 1000, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 1050, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 1100, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 1150, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 1200, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 1250, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 1300, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 1350, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 1400, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 1450, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 1500, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 1550, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 1600, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 1650, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 1700, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 1750, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 1800, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 1850, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 1900, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 1950, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 2000, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 2050, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 2100, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 2150, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 2200, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 2250, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 2300, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 2350, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 2400, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 2450, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 2500, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 2550, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 2600, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 2650, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 2700, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 2750, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 2800, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 2850, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 2900, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 2950, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 3000, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 3050, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 3100, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 3150, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 3200, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 3250, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 3300, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 3350, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 3400, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 3450, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 3500, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 3550, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 3600, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 3650, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 3700, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 3750, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 3800, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 3850, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 3900, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 3950, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 4000, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 4050, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 4100, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 4150, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 4200, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 4250, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 4300, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 4350, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 4400, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 4450, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 4500, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 4550, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 4600, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 4650, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 4700, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 4750, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 4800, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 4850, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 4900, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 4950, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 5000, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 5050, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 5100, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 5150, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 5200, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 5250, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 5300, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 5350, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 5400, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 5450, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 5500, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 5550, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 5600, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 5650, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 5700, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 5750, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 5800, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 5850, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 5900, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 5950, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 6000, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 6050, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 6100, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 6150, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 6200, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 6250, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 6300, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 6350, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 6400, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 6450, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 6500, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 6550, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 6600, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 6650, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 6700, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 6750, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 6800, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 6850, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 6900, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 6950, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 7000, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 7050, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 7100, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 7150, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 7200, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 7250, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 7300, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 7350, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 7400, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 7450, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 7500, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 7550, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 7600, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 7650, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 7700, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 7750, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 7800, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 7850, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 7900, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 7950, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('fence', initialDelayX + 1500, 270, 80, 80), // Doubled size, adjusted Y
                    createGameObject('low_fence', initialDelayX + 2100, 290, 40, 60), /* Adjusted size and Y */
                    createGameObject('spike', initialDelayX + 2700, 330, 30, 20),
                    createGameObject('blade', initialDelayX + 3300, 320, 30, 30, { type: 'horizontal', range: 100, speed: 5 }),
                    createGameObject('wool', initialDelayX + 3900, 180, 60, 60), // Doubled size, appeared in sky
                    createGameObject('giant_cheese', initialDelayX + 4500, 0, 90, 90), // Giant cheese at mid-level, starts at y=0 to fall
                    createGameObject('fence', initialDelayX + 4500, 270, 80, 80), // Doubled size, adjusted Y
                    createGameObject('low_fence', initialDelayX + 5100, 290, 40, 60), /* Adjusted size and Y */
                    createGameObject('spike', initialDelayX + 5700, 330, 30, 20),
                    createGameObject('blade', initialDelayX + 6300, 260, 30, 30, { type: 'vertical', range: 60, speed: 3 }),
                    createGameObject('wool', initialDelayX + 6900, 180, 60, 60), // Doubled size, appeared in sky
                    createGameObject('fence', initialDelayX + 7500, 270, 80, 80), // Doubled size, adjusted Y
                    createGameObject('low_fence', initialDelayX + 8100, 290, 40, 60), /* Adjusted size and Y */
                    createGameObject('spike', initialDelayX + 8700, 330, 30, 20),
                    createGameObject('blade', initialDelayX + 9300, 320, 30, 30, { type: 'horizontal', range: 100, speed: 5 })
                ],
                baseTerrain: [
                    { x: 0, y: 350, width: initialDelayX + 300, height: 50 }, // Starting platform
                    { x: initialDelayX + 400, y: 300, width: 200, height: 50 },
                    { x: initialDelayX + 700, y: 350, width: 200, height: 50 },
                    { x: initialDelayX + 1000, y: 310, width: 150, height: 40 },
                    { x: initialDelayX + 1200, y: 350, width: 500, height: 50 },
                    { x: initialDelayX + 1800, y: 300, width: 200, height: 50 },
                    { x: initialDelayX + 2100, y: 350, width: 600, height: 50 },
                    { x: initialDelayX + 2800, y: 320, width: 200, height: 50 },
                    { x: initialDelayX + 3100, y: 350, width: 800, height: 50 },
                    { x: initialDelayX + 4000, y: 300, width: 300, height: 50 },
                    { x: initialDelayX + 4400, y: 350, width: 2000, height: 50 },
                    { x: initialDelayX + 6500, y: 280, width: 400, height: 50 },
                    { x: initialDelayX + 7000, y: 350, width: 1000, height: 50 },
                    { x: initialDelayX + 8200, y: 310, width: 500, height: 50 },
                    { x: initialDelayX + 8800, y: 350, width: 1500, height: 50 }
                ]
            },
            3: {
                name: 'Imposible',
                scrollSpeed: 25.2 * 0.85, /* Reduced by 15% */
                practicePoints: [0, 10, 20, 30, 40],
                previewColor: '#FF0000',
                baseObjects: [
                    createGameObject('low_fence', initialDelayX + 800, 290, 40, 60),
                    createGameObject('spike', initialDelayX + 1000, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 1200, 260, 90, 90),
                    createGameObject('fence', initialDelayX + 1500, 270, 80, 80),
                    createGameObject('spring', initialDelayX + 1700, 330, 30, 20),
                    createGameObject('wool', initialDelayX + 1900, 180, 60, 60),
                    createGameObject('blade', initialDelayX + 2200, 260, 30, 30, { type: 'vertical', range: 80, speed: 4 }),
                    createGameObject('low_fence', initialDelayX + 2500, 290, 40, 60),
                    createGameObject('spike', initialDelayX + 2700, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 2900, 260, 90, 90),
                    createGameObject('fence', initialDelayX + 3200, 270, 80, 80),
                    createGameObject('spring', initialDelayX + 3400, 330, 30, 20),
                    createGameObject('wool', initialDelayX + 3600, 180, 60, 60),
                    createGameObject('blade', initialDelayX + 3900, 320, 30, 30, { type: 'horizontal', range: 100, speed: 6 }),
                    createGameObject('low_fence', initialDelayX + 4200, 290, 40, 60),
                    createGameObject('spike', initialDelayX + 4400, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 4600, 260, 90, 90),
                    createGameObject('fence', initialDelayX + 4900, 270, 80, 80),
                    createGameObject('spring', initialDelayX + 5100, 330, 30, 20),
                    createGameObject('wool', initialDelayX + 5300, 180, 60, 60),
                    createGameObject('blade', initialDelayX + 5600, 260, 30, 30, { type: 'vertical', range: 90, speed: 5 }),
                    createGameObject('low_fence', initialDelayX + 5900, 290, 40, 60),
                    createGameObject('spike', initialDelayX + 6100, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 6300, 260, 90, 90),
                    createGameObject('fence', initialDelayX + 6600, 270, 80, 80),
                    createGameObject('spring', initialDelayX + 6800, 330, 30, 20),
                    createGameObject('wool', initialDelayX + 7000, 180, 60, 60),
                    createGameObject('blade', initialDelayX + 7300, 320, 30, 30, { type: 'horizontal', range: 120, speed: 7 }),
                    createGameObject('low_fence', initialDelayX + 7600, 290, 40, 60),
                    createGameObject('spike', initialDelayX + 7800, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 8000, 260, 90, 90),
                    createGameObject('fence', initialDelayX + 8300, 270, 80, 80),
                    createGameObject('spring', initialDelayX + 8500, 330, 30, 20),
                    createGameObject('wool', initialDelayX + 8700, 180, 60, 60),
                    createGameObject('blade', initialDelayX + 9000, 260, 30, 30, { type: 'vertical', range: 100, speed: 6 }),
                    createGameObject('low_fence', initialDelayX + 9300, 290, 40, 60),
                    createGameObject('spike', initialDelayX + 9500, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 9700, 260, 90, 90),
                    createGameObject('fence', initialDelayX + 10000, 270, 80, 80),
                    createGameObject('spring', initialDelayX + 10200, 330, 30, 20),
                    createGameObject('wool', initialDelayX + 10400, 180, 60, 60),
                    createGameObject('blade', initialDelayX + 10700, 320, 30, 30, { type: 'horizontal', range: 140, speed: 8 }),
                    createGameObject('low_fence', initialDelayX + 11000, 290, 40, 60),
                    createGameObject('spike', initialDelayX + 11200, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 11400, 260, 90, 90),
                    createGameObject('fence', initialDelayX + 11700, 270, 80, 80),
                    createGameObject('spring', initialDelayX + 11900, 330, 30, 20),
                    createGameObject('wool', initialDelayX + 12100, 180, 60, 60),
                    createGameObject('blade', initialDelayX + 12400, 260, 30, 30, { type: 'vertical', range: 110, speed: 7 }),
                    createGameObject('low_fence', initialDelayX + 12700, 290, 40, 60),
                    createGameObject('spike', initialDelayX + 12900, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 13100, 260, 90, 90),
                    createGameObject('fence', initialDelayX + 13400, 270, 80, 80),
                    createGameObject('spring', initialDelayX + 13600, 330, 30, 20),
                    createGameObject('wool', initialDelayX + 13800, 180, 60, 60),
                    createGameObject('blade', initialDelayX + 14100, 320, 30, 30, { type: 'horizontal', range: 160, speed: 9 }),
                    createGameObject('low_fence', initialDelayX + 14400, 290, 40, 60),
                    createGameObject('spike', initialDelayX + 14600, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 14800, 260, 90, 90),
                    createGameObject('fence', initialDelayX + 15100, 270, 80, 80),
                    createGameObject('spring', initialDelayX + 15300, 330, 30, 20),
                    createGameObject('wool', initialDelayX + 15500, 180, 60, 60),
                    createGameObject('blade', initialDelayX + 15800, 260, 30, 30, { type: 'vertical', range: 120, speed: 8 }),
                    createGameObject('low_fence', initialDelayX + 16100, 290, 40, 60),
                    createGameObject('spike', initialDelayX + 16300, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 16500, 260, 90, 90),
                    createGameObject('fence', initialDelayX + 16800, 270, 80, 80),
                    createGameObject('spring', initialDelayX + 17000, 330, 30, 20),
                    createGameObject('wool', initialDelayX + 17200, 180, 60, 60),
                    createGameObject('blade', initialDelayX + 17500, 320, 30, 30, { type: 'horizontal', range: 180, speed: 10 }),
                    createGameObject('low_fence', initialDelayX + 17800, 290, 40, 60),
                    createGameObject('spike', initialDelayX + 18000, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 18200, 260, 90, 90),
                    createGameObject('fence', initialDelayX + 18500, 270, 80, 80),
                    createGameObject('spring', initialDelayX + 18700, 330, 30, 20),
                    createGameObject('wool', initialDelayX + 18900, 180, 60, 60),
                    createGameObject('blade', initialDelayX + 19200, 260, 30, 30, { type: 'vertical', range: 130, speed: 9 }),
                    createGameObject('low_fence', initialDelayX + 19500, 290, 40, 60),
                    createGameObject('spike', initialDelayX + 19700, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 19900, 260, 90, 90)
                ],
                baseTerrain: [
                    { x: 0, y: 350, width: initialDelayX + 300, height: 50 }, // Starting platform
                    { x: initialDelayX + 400, y: 300, width: 200, height: 50 },
                    { x: initialDelayX + 700, y: 350, width: 200, height: 50 },
                    { x: initialDelayX + 1000, y: 310, width: 150, height: 40 },
                    { x: initialDelayX + 1200, y: 350, width: 500, height: 50 },
                    { x: initialDelayX + 1800, y: 300, width: 200, height: 50 },
                    { x: initialDelayX + 2100, y: 350, width: 600, height: 50 },
                    { x: initialDelayX + 2800, y: 320, width: 200, height: 50 },
                    { x: initialDelayX + 3100, y: 350, width: 800, height: 50 },
                    { x: initialDelayX + 4000, y: 300, width: 300, height: 50 },
                    { x: initialDelayX + 4400, y: 350, width: 2000, height: 50 },
                    { x: initialDelayX + 6500, y: 280, width: 400, height: 50 },
                    { x: initialDelayX + 7000, y: 350, width: 1000, height: 50 },
                    { x: initialDelayX + 8200, y: 310, width: 500, height: 50 },
                    { x: initialDelayX + 8800, y: 350, width: 1500, height: 50 },
                    // Ceiling for Level 3
                    { x: initialDelayX + 1000, y: 0, width: 2000, height: 50 } // Ceiling segment
                ]
            }
        };

        // Generates objects and terrain for each level at startup
        for (let levelId in levels) {
            levels[levelId].objects = generateLevelObjects(levels[levelId].baseObjects, levels[levelId].scrollSpeed, 45);
            levels[levelId].terrain = generateTerrain(levels[levelId].baseTerrain, levels[levelId].scrollSpeed, 45);
        }

        // --- Main Game Loop ---

        /**
         * Main game loop that runs every frame.
         * @param {DOMHighResTimeStamp} timestamp - The current time provided by requestAnimationFrame.
         */
        function gameLoop(timestamp) {
            if (!gameRunning || isPaused) return;
            update(timestamp);
            render();
            requestAnimationFrame(gameLoop);
        }

        /**
         * Updates the game state every frame.
         * @param {DOMHighResTimeStamp} timestamp - The current time.
         */
        function update(timestamp) {
            // Update player jump
            updateJump();
            // Apply gravity
            player.vy += gravity;
            player.y += player.vy;

            let onGround = false;
            let currentSegment = null;

            // Collision detection with terrain
            for (let segment of terrain) {
                const segX = segment.x - scrollPosition;

                // Check for collision with terrain segment
                if (player.x + player.width > segX && player.x < segX + segment.width) {
                    // Collision from bottom (landing on ground)
                    if (player.vy >= 0 && player.y + player.height > segment.y && player.y + player.height <= segment.y + player.vy + 10) {
                        player.y = segment.y - player.height;
                        player.vy = 0;
                        player.jumping = false;
                        player.jumpHoldTime = 0;
                        onGround = true;
                        break; // Player landed, no need to check other segments for landing
                    }
                    // Collision from top (hitting a ceiling)
                    if (player.vy < 0 && player.y < segment.y + segment.height && player.y + player.height > segment.y) {
                        handleDeath(); // Hit ceiling, player dies
                        return; // Exit update function as player died
                    }
                }
                // If player is not on the ground and falls below a terrain segment
                if (!onGround && currentSegment && player.y + player.height > currentSegment.y) {
                    let hasLowerSegment = false;
                    for (let segment of terrain) {
                        const segX = segment.x - scrollPosition;
                        if (player.x + player.width > segX && player.x < segX + segment.width &&
                            segment.y > currentSegment.y && player.y + player.height >= segment.y) {
                            hasLowerSegment = true;
                            break;
                        }
                    }
                    if (!hasLowerSegment) {
                        handleDeath();
                        return;
                    }
                }
            }

            // If player falls below the canvas (off-screen)
            if (!onGround && player.y > BASE_CANVAS_HEIGHT) { // Usar BASE_CANVAS_HEIGHT
                handleDeath();
                return;
            }

            // Limit player from going off the top
            if (player.y < 0) {
                player.y = 0;
                player.vy = 0;
            }

            // Scroll the level
            scrollPosition += scrollSpeed;

            // Logic to add objects to the game based on their world position
            levels[currentLevel].objects.forEach(baseObj => {
                const alreadyActive = objects.some(activeObj => activeObj.id === baseObj.id);
                if (!alreadyActive) {
                    const screenX = baseObj.position.x - scrollPosition;
                    if (screenX <= BASE_CANVAS_WIDTH + 50 && baseObj.position.x > scrollPosition + player.x - 100) { // Usar BASE_CANVAS_WIDTH
                        const newObj = { ...baseObj, currentY: baseObj.position.y };
                        if (newObj.type === 'cheese' || newObj.type === 'giant_cheese') { // Apply falling to giant cheese too
                            newObj.currentY = 0;
                            newObj.targetY = baseObj.position.y; // Use original Y as target
                            newObj.fallSpeed = 5;
                            newObj.falling = true;
                        } else {
                            newObj.currentY = newObj.position.y;
                        }
                        objects.push(newObj);
                    }
                }
            });
            // Filter out objects that have already passed the screen
            objects = objects.filter(obj => (obj.position.x - scrollPosition) > -obj.width);


            // Update position of moving and falling objects
            objects.forEach(obj => {
                if (obj.falling) {
                    obj.currentY += obj.fallSpeed;
                    if (obj.currentY >= obj.targetY) {
                        obj.currentY = obj.targetY;
                        obj.falling = false;
                    }
                }
                if (!obj.falling && obj.moving) {
                    if (obj.moving.type === 'vertical') {
                        obj.currentY += obj.moving.speed;
                        if (obj.currentY > obj.position.y || obj.currentY < obj.position.y - obj.moving.range) {
                            obj.moving.speed = -obj.moving.speed;
                        }
                    } else if (obj.moving.type === 'horizontal') {
                        if (obj.originalX === undefined) {
                            obj.originalX = obj.position.x;
                        }
                        obj.position.x += obj.moving.speed;
                        if (obj.position.x > obj.originalX + obj.moving.range || obj.position.x < obj.originalX) {
                            obj.moving.speed = -obj.moving.speed;
                        }
                    }
                }
            });

            // Update particle position and opacity
            particles = particles.filter(p => p.alpha > 0);
            particles.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.alpha -= 0.02;
                p.size *= 0.98;
            });

            // Update clouds
            updateClouds(timestamp);

            // Player collision detection with objects
            objects.forEach((obj, index) => {
                const objX = obj.position.x - scrollPosition;
                if (objX < -50 || objX > BASE_CANVAS_WIDTH) return; // Usar BASE_CANVAS_WIDTH

                const objLeft = objX;
                const objRight = objX + obj.width;
                const objTop = obj.currentY || obj.position.y;
                const objBottom = objTop + obj.height;

                const playerLeft = player.x;
                const playerRight = player.x + player.width;
                const playerTop = player.y;
                const playerBottom = player.y + player.height;

                if (playerRight > objLeft && playerLeft < objRight && playerBottom > objTop && playerTop < objBottom) {
                    if (obj.type === 'wool') {
                        coins += 25;
                        localStorage.setItem('coins', coins);
                        coinDisplays.forEach(display => {
                            display.textContent = coins;
                            display.classList.add('highlight');
                            setTimeout(() => display.classList.remove('highlight'), 500);
                        });
                        createParticles(objX + obj.width / 2, objTop + obj.height / 2, 5, '#FFFFFF');
                        objects.splice(index, 1); // Remove wool when collected
                    } else if (obj.type === 'spring') {
                        player.vy = jumpStrength * 1.8;
                        player.jumping = true;
                        player.jumpHoldTime = 0;
                        createParticles(objX + obj.width / 2, objTop, 10, '#00FF00');
                        objects.splice(index, 1);
                    }
                    else if (obj.type === 'finish') {
                        gameRunning = false;
                        stopAudio();
                        const finalTime = (performance.now() - gameStartTime) / 1000;
                        document.getElementById('completionTime').textContent = `Tiempo: ${finalTime.toFixed(1)}s`;
                        levelComplete.style.display = 'block';
                        pauseButton.style.display = 'none';
                        objects = [];
                    } else { // Any other obstacle (fence, low_fence, spike, blade, cheese, giant_cheese)
                        handleDeath();
                    }
                }
            });
        }

        /**
         * Draws all game elements on the canvas.
         */
        function render() {
            ctx.clearRect(0, 0, BASE_CANVAS_WIDTH, BASE_CANVAS_HEIGHT); // Usar dimensiones base

            // Dibujar el fondo del cielo y pasto
            const skyHeight = BASE_CANVAS_HEIGHT * 0.6; // Usar dimensiones base
            const grassHeight = BASE_CANVAS_HEIGHT * 0.4; // Usar dimensiones base
            
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, BASE_CANVAS_WIDTH, skyHeight); // Usar dimensiones base

            drawClouds();

            ctx.fillStyle = '#a8e4a0';
            ctx.fillRect(0, skyHeight, BASE_CANVAS_WIDTH, grassHeight); // Usar dimensiones base

            ctx.fillStyle = '#8B4513';
            terrain.forEach(segment => {
                const x = segment.x - scrollPosition;
                if (x + segment.width > 0 && x < BASE_CANVAS_WIDTH) { // Usar dimensiones base
                    ctx.fillRect(x, segment.y, segment.width, segment.height);
                }
            });

            // Draw objects (obstacles and collectibles)
            objects.forEach(obj => {
                const x = obj.position.x - scrollPosition;
                if (x < -50 || x > BASE_CANVAS_WIDTH) return; // Usar dimensiones base
                const y = obj.currentY || obj.position.y;

                switch (obj.type) {
                    case 'cheese':
                    case 'giant_cheese': // Draw giant cheese using the same image
                        if (cheeseImage) {
                            ctx.drawImage(cheeseImage, x, y, obj.width, obj.height);
                        } else {
                            ctx.fillStyle = '#FFD700';
                            ctx.fillRect(x, y, obj.width, obj.height);
                        }
                        break;
                    case 'fence':
                        if (fenceImage) {
                            ctx.drawImage(fenceImage, x, y, obj.width, obj.height);
                        } else {
                            ctx.fillStyle = '#FFD700';
                            ctx.fillRect(x, y, obj.width, obj.height);
                        }
                        break;
                    case 'low_fence':
                        if (lowFenceImage) { // Use the loaded low fence image
                            ctx.drawImage(lowFenceImage, x, y, obj.width, obj.height);
                        } else {
                            ctx.fillStyle = '#FFA500';
                            ctx.fillRect(x, y, obj.width, obj.height);
                        }
                        break;
                    case 'spike':
                        if (spikeImage) {
                            ctx.drawImage(spikeImage, x, y, obj.width, obj.height);
                        } else {
                            ctx.fillStyle = '#FF0000';
                            ctx.beginPath();
                            ctx.moveTo(x, y + obj.height);
                            ctx.lineTo(x + obj.width / 2, y);
                            ctx.lineTo(x + obj.width, y + obj.height);
                            ctx.fill();
                        }
                        break;
                    case 'blade':
                        if (bladeImage) {
                            ctx.drawImage(bladeImage, x, y, obj.width, obj.height);
                        } else {
                            ctx.fillStyle = '#000000';
                            ctx.beginPath();
                            ctx.arc(x + obj.width / 2, y + obj.height / 2, obj.width / 2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        break;
                    case 'wool':
                        if (woolImage) {
                            ctx.drawImage(woolImage, x, y, obj.width, obj.height);
                        } else {
                            ctx.fillStyle = '#FFFFFF';
                            ctx.beginPath();
                            ctx.arc(x + obj.width / 2, y + obj.height / 2, obj.width / 2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        break;
                    case 'spring':
                        ctx.fillStyle = '#00FF00';
                        ctx.fillRect(x, y, obj.width, obj.height);
                        ctx.fillStyle = '#000000';
                        ctx.font = '10px Arial';
                        ctx.fillText('↑', x + obj.width / 2 - 4, y + obj.height / 2 + 4);
                        break;
                    case 'finish':
                        ctx.fillStyle = '#00FF00';
                        ctx.fillRect(x, y, obj.width, obj.height);
                        break;
                }
            });

            // Draw particles
            particles.forEach(p => {
                ctx.fillStyle = `rgba(${parseInt(p.color.slice(1, 3), 16)}, ${parseInt(p.color.slice(3, 5), 16)}, ${parseInt(p.color.slice(5, 7), 16)}, ${p.alpha})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size / 2, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw player (using image or color based on selected character)
            if (currentCharacter.isImage && currentCharacter.imageUrl) {
                let charImage = null;
                switch (currentCharacter.name) {
                    case 'Capybara': charImage = capybaraImage; break;
                    case 'Poop': charImage = poopImage; break;
                    case 'SúperDX123': charImage = estebanImage; break;
                    case 'lushli': charImage = kilyImage; break;
                    case 'Dragon': charImage = eycImage; break;
                }
                if (charImage) {
                    ctx.drawImage(charImage, player.x, player.y, player.width, player.height);
                } else {
                    ctx.fillStyle = currentCharacter.color;
                    ctx.fillRect(player.x, player.y, player.width, player.height);
                }
            } else {
                ctx.fillStyle = currentCharacter.color;
                ctx.fillRect(player.x, player.y, player.width, player.height);
            }

            // Draw level text, time, and progress
            ctx.fillStyle = 'black';
            ctx.font = '16px Arial';
            const currentTime = gameRunning ? (performance.now() - gameStartTime) / 1000 : 0;
            const totalLevelWidth = levels[currentLevel].scrollSpeed * 60 * 45;
            const progressPercentage = Math.min(100, (scrollPosition / totalLevelWidth) * 100).toFixed(1);
            ctx.fillText(`Nivel: ${levels[currentLevel].name} | Tiempo: ${currentTime.toFixed(1)}s | Progreso: ${progressPercentage}%`, 10, 20);
        }

        /**
         * Handles player jump logic.
         */
        function updateJump() {
            if (player.jumping && player.jumpHoldTime < player.maxJumpHold) {
                player.vy = jumpStrength * (1 - player.jumpHoldTime / player.maxJumpHold);
                player.jumpHoldTime += 16;
            }
        }

        /**
         * Handles player death.
         */
        function handleDeath() {
            gameRunning = false;
            stopAudio();
            playAudio(deathSoundBuffer);
            showError('¡Has muerto! Inténtalo de nuevo.');
            returnToMenu();
            objects = [];
            particles = [];
        }

        // --- Menu and Game Control Functions ---

        /**
         * Starts the game with the specified level.
         * @param {number} levelId - The ID of the level to start.
         */
        function startGame(levelId) {
            if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    console.log('AudioContext reanudado');
                    startAudioAndGame(levelId);
                }).catch(e => {
                    console.error('Error al reanudar AudioContext:', e);
                    startAudioAndGame(levelId);
                });
            } else {
                startAudioAndGame(levelId);
            }
        }

        /**
         * Helper function to start audio and game after AudioContext resumption.
         * @param {number} levelId - The ID of the level to start.
         */
        function startAudioAndGame(levelId) {
            stopAudio();
            if (audioBuffer) {
                audioSource = playAudio(audioBuffer);
                if (audioSource) {
                    const levelDurationSeconds = 45;
                    audioTimeoutId = setTimeout(() => {
                        stopAudio();
                    }, levelDurationSeconds * 1000);
                }
            }

            currentLevel = levelId;
            scrollPosition = 0;
            player.x = 100;
            player.y = 300;
            player.vy = 0;
            player.jumping = false;
            player.jumpHoldTime = 0;
            objects = [];
            terrain = levels[currentLevel].terrain;
            scrollSpeed = levels[currentLevel].scrollSpeed;
            clouds = [];
            lastCloudSpawnTime = 0;
            objectIdCounter = 0;

            menu.style.display = 'none';
            levelSelect.style.display = 'none';
            pauseMenu.style.display = 'none';
            characterMenu.style.display = 'none';
            levelComplete.style.display = 'none';
            pauseButton.style.display = 'flex';
            startScreen.style.display = 'none'; // Asegurarse de ocultar la pantalla de inicio

            gameRunning = true;
            isPaused = false;
            gameStartTime = performance.now();
            requestAnimationFrame(gameLoop);
        }

        /**
         * Resumes the game from the pause menu.
         */
        function resumeGame() {
            isPaused = false;
            pauseMenu.style.display = 'none';
            pauseButton.style.display = 'flex';
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            requestAnimationFrame(gameLoop);
        }

        /**
         * Toggles the game pause state.
         */
        function togglePause() {
            isPaused = !isPaused;
            if (isPaused) {
                pauseMenu.style.display = 'block';
                pauseButton.style.display = 'none';
                if (audioContext.state === 'running') {
                    audioContext.suspend();
                }
            } else {
                resumeGame();
            }
        }

        /**
         * Muestra el menú principal desde la pantalla de inicio.
         */
        function showMainMenuFromStartScreen() {
            cancelAnimationFrame(startScreenAnimationId); // Detener la animación de la pantalla de inicio
            startScreen.style.display = 'none';
            menu.style.display = 'block';
            updateCoinDisplays();
        }

        /**
         * Shows the level selection menu.
         */
        function showLevelSelect() {
            menu.style.display = 'none';
            levelSelect.style.display = 'block';
            updateCoinDisplays();
            renderLevelList();
        }

        /**
         * Shows the character selection menu.
         */
        function showCharacters() {
            menu.style.display = 'none';
            pauseMenu.style.display = 'none';
            characterMenu.style.display = 'block';
            updateCoinDisplays();
            renderCharacterList();
        }

        /**
         * Returns to the main menu from any other menu.
         */
        function returnToMenu() {
            gameRunning = false;
            isPaused = false;
            stopAudio();
            menu.style.display = 'block';
            levelSelect.style.display = 'none';
            pauseMenu.style.display = 'none';
            characterMenu.style.display = 'none';
            levelComplete.style.display = 'none';
            pauseButton.style.display = 'none';
            updateCoinDisplays();
            // Si volvemos al menú principal, no volvemos a la pantalla de inicio
            // Si se quisiera volver a la pantalla de inicio, se llamaría a initStartScreen() y animateStartScreen() aquí
        }

        /**
         * Toggles practice mode.
         */
        function togglePractice() {
            practiceMode = !practiceMode;
            showError(`Modo Práctica: ${practiceMode ? 'Activado' : 'Desactivado'}`);
        }

        /**
         * Updates coin text in all displays.
         */
        function updateCoinDisplays() {
            coinDisplays.forEach(display => display.textContent = coins);
        }

        /**
         * Renders the list of levels in the level selection menu.
         */
        function renderLevelList() {
            const levelListDiv = document.getElementById('levelList');
            levelListDiv.innerHTML = '';
            for (let id in levels) {
                const level = levels[id];
                const levelDiv = document.createElement('div');
                levelDiv.className = 'level-preview';
                levelDiv.style.backgroundColor = level.previewColor;
                levelDiv.textContent = level.name;
                levelDiv.onclick = () => startGame(parseInt(id));
                levelListDiv.appendChild(levelDiv);
            }
        }

        /**
         * Renders the list of characters in the character selection menu.
         */
        function renderCharacterList() {
            const characterListDiv = document.getElementById('characterList');
            characterListDiv.innerHTML = '';

            characters.forEach(char => {
                const charOption = document.createElement('div');
                charOption.className = 'character-option';
                if (char.name === currentCharacter.name) {
                    charOption.classList.add('selected');
                }

                if (char.isImage && char.imageUrl) {
                    const img = document.createElement('img');
                    img.src = char.imageUrl;
                    img.alt = char.name;
                    charOption.appendChild(img);
                } else {
                    const colorBox = document.createElement('div');
                    colorBox.className = 'character-color-box';
                    colorBox.style.backgroundColor = char.color;
                    charOption.appendChild(colorBox);
                }

                const nameP = document.createElement('p');
                nameP.textContent = char.name;
                charOption.appendChild(nameP);

                if (char.unlocked) {
                    const selectButton = document.createElement('button');
                    selectButton.textContent = 'Seleccionar';
                    selectButton.onclick = () => {
                        currentCharacter = char;
                        renderCharacterList();
                    };
                    selectButton.disabled = (char.name === currentCharacter.name);
                    charOption.appendChild(selectButton);
                } else {
                    const costP = document.createElement('p');
                    costP.className = 'cost';
                    costP.textContent = `Costo: ${char.cost} Monedas`;
                    charOption.appendChild(costP);

                    const buyButton = document.createElement('button');
                    buyButton.textContent = 'Comprar';
                    buyButton.disabled = (coins < char.cost);
                    buyButton.onclick = () => {
                        if (coins >= char.cost) {
                            coins -= char.cost;
                            char.unlocked = true;
                            localStorage.setItem('coins', coins);
                            const currentSavedChars = localStorage.getItem('characters') ? JSON.parse(localStorage.getItem('characters')) : [];
                            currentSavedChars.push(char.name);
                            localStorage.setItem('characters', JSON.stringify(currentSavedChars));
                            updateCoinDisplays();
                            renderCharacterList();
                            showError(`¡${char.name} desbloqueado!`);
                        } else {
                            showError('¡No tienes suficientes monedas!');
                        }
                    };
                    charOption.appendChild(buyButton);
                }
                characterListDiv.appendChild(charOption);
            });
        }

        // --- Responsiveness Logic ---

        /**
         * Adjusts the canvas size based on the container's dimensions.
         * This function should be called on window load and resize.
         */
        function resizeGame() {
            const containerWidth = gameContainer.offsetWidth;
            const containerHeight = gameContainer.offsetHeight;

            // Calcular dimensiones para ajustarse al contenedor manteniendo la relación de aspecto
            const aspectRatio = BASE_CANVAS_WIDTH / BASE_CANVAS_HEIGHT;
            let targetWidth = containerWidth;
            let targetHeight = containerWidth / aspectRatio;

            if (targetHeight > containerHeight) {
                targetHeight = containerHeight;
                targetWidth = containerHeight * aspectRatio;
            }

            // Establecer las dimensiones CSS del elemento canvas
            canvas.style.width = `${targetWidth}px`;
            canvas.style.height = `${targetHeight}px`;

            // Establecer el tamaño del buffer de dibujo interno a la resolución base
            // Esto significa que todas las operaciones de dibujo ocurrirán en un canvas virtual de 800x400,
            // y el navegador escalará esta imagen de 800x400 para ajustarse a las dimensiones CSS.
            canvas.width = BASE_CANVAS_WIDTH;
            canvas.height = BASE_CANVAS_HEIGHT;

            // Re-renderizar el juego para que se ajuste al nuevo tamaño del canvas
            if (gameRunning) {
                render();
            } else if (startScreen.style.display === 'flex') {
                renderStartScreen(); // Si la pantalla de inicio está activa, renderizarla
            }
        }

        // --- Start Screen Logic ---

        /**
         * Inicializa los objetos que caen en la pantalla de inicio.
         */
        function initStartScreen() {
            startScreenObjects = [];
            // Añadir algunos objetos para que caigan
            for (let i = 0; i < 10; i++) {
                startScreenObjects.push({
                    type: Math.random() < 0.5 ? 'cheese' : 'wool',
                    x: Math.random() * BASE_CANVAS_WIDTH,
                    y: -Math.random() * BASE_CANVAS_HEIGHT, // Empiezan por encima del canvas
                    width: 30 + Math.random() * 30,
                    height: 30 + Math.random() * 30,
                    vy: 1 + Math.random() * 3 // Velocidad de caída
                });
            }
        }

        /**
         * Actualiza la posición de los objetos en la pantalla de inicio.
         */
        function updateStartScreen() {
            startScreenObjects.forEach(obj => {
                obj.y += obj.vy;
                // Si el objeto cae por debajo del canvas, resetearlo arriba
                if (obj.y > BASE_CANVAS_HEIGHT) {
                    obj.y = -obj.height;
                    obj.x = Math.random() * BASE_CANVAS_WIDTH;
                }
            });
        }

        /**
         * Dibuja los objetos en la pantalla de inicio.
         */
        function renderStartScreen() {
            // Limpiar el canvas
            ctx.clearRect(0, 0, BASE_CANVAS_WIDTH, BASE_CANVAS_HEIGHT);

            // Dibujar el fondo oscuro semi-transparente en el canvas
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(0, 0, BASE_CANVAS_WIDTH, BASE_CANVAS_HEIGHT);

            // Dibujar los objetos que caen
            startScreenObjects.forEach(obj => {
                let image = null;
                if (obj.type === 'cheese' && cheeseImage) {
                    image = cheeseImage;
                } else if (obj.type === 'wool' && woolImage) {
                    image = woolImage;
                }

                if (image) {
                    ctx.drawImage(image, obj.x, obj.y, obj.width, obj.height);
                } else {
                    // Fallback a un color si la imagen no carga
                    ctx.fillStyle = obj.type === 'cheese' ? '#FFD700' : '#FFFFFF';
                    ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
                }
            });
        }

        /**
         * Bucle de animación para la pantalla de inicio.
         */
        function animateStartScreen() {
            updateStartScreen();
            renderStartScreen();
            startScreenAnimationId = requestAnimationFrame(animateStartScreen);
        }


        // --- Event Listeners ---

        // Handle jump with spacebar
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && gameRunning && !isPaused && !player.jumping) {
                player.jumping = true;
                player.jumpHoldTime = 0;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space' && gameRunning && !isPaused && player.jumping) {
                player.jumping = false;
            }
        });

        // Handle jump with mouse click on canvas
        canvas.addEventListener('mousedown', (e) => {
            if (gameRunning && !isPaused && !player.jumping) {
                player.jumping = true;
                player.jumpHoldTime = 0;
            }
        });

        // Handle jump with touch on canvas for mobile
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Prevent default touch behavior like scrolling
            if (gameRunning && !isPaused && !player.jumping) {
                player.jumping = true;
                player.jumpHoldTime = 0;
            }
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (gameRunning && !isPaused && player.jumping) {
                player.jumping = false;
            }
        });

        // Event to start loading assets when window is fully loaded
        window.onload = function () {
            loadAssets();
            resizeGame(); // Initial resize when the page loads
        };

        // Event listener for window resize
        window.addEventListener('resize', resizeGame);

    </script>
</body>
</html>
