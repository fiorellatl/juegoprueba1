<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Capybara Dash - Juego</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: #f0f0f0;
            font-family: 'Inter', Arial, sans-serif; /* Usando Inter como fuente principal */
        }
        #gameCanvas {
            border: 1px solid #000;
            background: linear-gradient(to bottom, #87CEEB, #a8e4a0); /* Cielo y pasto */
            border-radius: 10px; /* Bordes redondeados */
            box-shadow: 0 0 15px rgba(0,0,0,0.4); /* Sombra para el canvas */
        }
        #menu, #pauseMenu, #levelSelect, #characterMenu, #levelComplete {
            position: absolute;
            background: rgba(255, 255, 255, 0.95); /* Fondo ligeramente más opaco */
            padding: 30px; /* Más padding */
            border-radius: 15px; /* Más redondeado */
            text-align: center;
            display: none;
            box-shadow: 0 0 20px rgba(0,0,0,0.4); /* Sombra más pronunciada */
            border: 2px solid #4CAF50; /* Borde verde */
        }
        h2 {
            color: #333;
            margin-top: 0;
            font-size: 2em;
        }
        button {
            padding: 12px 25px; /* Más padding */
            margin: 8px; /* Más margen */
            cursor: pointer;
            background: linear-gradient(to bottom, #4CAF50, #45a049); /* Degradado */
            color: white;
            border: none;
            border-radius: 8px; /* Más redondeado */
            font-size: 18px; /* Fuente más grande */
            font-weight: bold;
            transition: all 0.3s ease; /* Transición suave */
            box-shadow: 0 4px 6px rgba(0,0,0,0.2); /* Sombra para botones */
        }
        button:hover {
            background: linear-gradient(to bottom, #45a049, #3e8e41);
            transform: translateY(-2px); /* Efecto de elevación */
            box-shadow: 0 6px 8px rgba(0,0,0,0.3);
        }
        button:active {
            transform: translateY(1px); /* Efecto de clic */
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        button:disabled {
            background: #cccccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        #coinDisplay, #coinDisplayPause, #coinDisplayLevel, #coinDisplayCharacter {
            font-weight: bold;
            font-size: 1.2em;
            color: #555;
            transition: color 0.5s;
        }
        .highlight {
            color: #FFD700; /* Color de oro para resaltar monedas */
            text-shadow: 0 0 5px rgba(255,215,0,0.7);
        }
        #levelComplete h2 {
            font-size: 28px;
            color: #4CAF50;
        }
        #levelComplete p {
            font-size: 20px;
            color: #333;
        }
        .level-preview {
            width: 120px; /* Más grande */
            height: 70px; /* Más grande */
            margin: 12px;
            display: inline-block;
            border: 3px solid #333; /* Borde más grueso */
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .level-preview:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        .character-option {
            display: inline-block;
            margin: 15px;
            padding: 10px;
            border: 2px solid #ccc;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }
        .character-option.selected {
            border-color: #4CAF50;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
            background-color: #e6ffe6;
        }
        .character-option:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 10px rgba(0,0,0,0.2);
        }
        .character-option img {
            width: 60px;
            height: 60px;
            border-radius: 5px;
            margin-bottom: 5px;
        }
        .character-option .character-color-box {
            width: 60px;
            height: 60px;
            border-radius: 5px;
            margin: 0 auto 5px auto;
            border: 1px solid #eee;
        }
        .character-option p {
            margin: 0;
            font-weight: bold;
            color: #333;
        }
        .character-option .cost {
            font-size: 0.9em;
            color: #777;
        }
        .character-option button {
            margin-top: 10px;
            padding: 8px 15px;
            font-size: 14px;
        }

        #pauseButton {
            position: absolute;
            top: 20px; /* Más margen */
            left: 50%;
            transform: translateX(-50%);
            width: 40px; /* Más grande */
            height: 40px; /* Más grande */
            background: #FF0000;
            border-radius: 50%;
            cursor: pointer;
            display: none;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            transition: background 0.3s ease;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: white;
            font-weight: bold;
        }
        #pauseButton:hover {
            background: #CC0000;
        }
        #errorMessage {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 0, 0, 0.9);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            display: none;
            box-shadow: 0 0 10px rgba(255,0,0,0.5);
            font-weight: bold;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="400"></canvas>

    <div id="menu">
        <h2>Capybara Dash</h2>
        <button onclick="startGame(1)">Jugar</button>
        <button onclick="showLevelSelect()">Seleccionar Nivel</button>
        <button onclick="showCharacters()">Seleccionar Personaje</button>
        <button onclick="togglePractice()">Modo Práctica</button>
        <p>Monedas: <span id="coinDisplay">0</span></p>
    </div>

    <div id="levelSelect">
        <h2>Seleccionar Nivel</h2>
        <div id="levelList"></div>
        <button onclick="returnToMenu()">Volver</button>
        <p>Monedas: <span id="coinDisplayLevel">0</span></p>
    </div>

    <div id="pauseMenu">
        <h2>Pausado</h2>
        <button onclick="resumeGame()">Reanudar</button>
        <button onclick="togglePractice()">Modo Práctica</button>
        <button onclick="showCharacters()">Seleccionar Personaje</button>
        <button onclick="returnToMenu()">Menú Principal</button>
        <p>Monedas: <span id="coinDisplayPause">0</span></p>
    </div>

    <div id="characterMenu">
        <h2>Seleccionar Personaje</h2>
        <div id="characterList"></div>
        <button onclick="returnToMenu()">Volver</button>
        <p>Monedas: <span id="coinDisplayCharacter">0</span></p>
    </div>

    <div id="levelComplete">
        <h2>¡Buena, Capybara! ¡Lo lograste!</h2>
        <p id="completionTime"></p>
        <button onclick="returnToMenu()">Menú Principal</button>
    </div>

    <div id="pauseButton" onclick="togglePause()">II</div>

    <div id="errorMessage"></div>

    <script>
        // --- Global Variables and DOM Elements ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const menu = document.getElementById('menu');
        const levelSelect = document.getElementById('levelSelect');
        const pauseMenu = document.getElementById('pauseMenu');
        const characterMenu = document.getElementById('characterMenu');
        const levelComplete = document.getElementById('levelComplete');
        const pauseButton = document.getElementById('pauseButton');
        const errorMessage = document.getElementById('errorMessage');

        // Player coins, loaded from localStorage or initialized to 0
        let coins = localStorage.getItem('coins') ? parseInt(localStorage.getItem('coins')) : 0;
        const coinDisplays = [
            document.getElementById('coinDisplay'),
            document.getElementById('coinDisplayPause'),
            document.getElementById('coinDisplayLevel'),
            document.getElementById('coinDisplayCharacter')
        ];
        // Update coin display in all locations
        coinDisplays.forEach(display => display.textContent = coins);

        // Character definitions
        const characters = [
            { name: 'Sheep', cost: 0, color: '#FFFFFF', unlocked: true, isImage: true, imageUrl: 'sheep.png' },
            { name: 'Poop', cost: 100, color: '#8B4513', unlocked: false, isImage: true, imageUrl: 'poop.png' },
            { name: 'Lion', cost: 200, color: '#FFA500', unlocked: false, isImage: true, imageUrl: 'esteban.png' }, // Now uses esteban.png
            { name: 'Penguin', cost: 300, color: '#000000', unlocked: false, isImage: true, imageUrl: 'kily.png' }, // Now uses kily.png
            { name: 'Dragon', cost: 400, color: '#8A2BE2', unlocked: false, isImage: true, imageUrl: 'eyc.png' }
        ];
        let currentCharacter = characters[0]; // Initial character
        // Load unlocked characters from localStorage
        const savedCharacters = localStorage.getItem('characters') ? JSON.parse(localStorage.getItem('characters')) : ['Sheep'];
        characters.forEach(char => {
            if (savedCharacters.includes(char.name)) char.unlocked = true;
        });

        // --- Audio Configuration (Web Audio API) ---
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let audioBuffer = null; // Buffer for background music (TNT.mp3)
        let audioSource = null; // Current audio source for background music
        let audioStartTime = 0; // Time when music started
        let deathSoundBuffer = null; // Buffer for death sound
        
        // Asset paths
        const audioUrl = 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3'; // Example music URL
        const deathSoundUrl = 'https://www.myinstants.com/media/sounds/8bit_explosion.mp3'; // External URL for death sound
        const sheepImageUrl = 'sheep.png';
        const poopImageUrl = 'poop.png';
        const cheeseImageUrl = 'cheese.png';
        const eycImageUrl = 'eyc.png';
        const estebanImageUrl = 'esteban.png'; // New image URL
        const kilyImageUrl = 'kily.png';     // New image URL

        // Image buffers
        let sheepImage = null;
        let poopImage = null;
        let cheeseImage = null;
        let eycImage = null;
        let estebanImage = null; // New image buffer
        let kilyImage = null;     // New image buffer

        // --- Game Variables ---
        let particles = []; // Particles for visual effects
        let gameRunning = false; // Game state (running or not)
        let isPaused = false; // Pause state
        let currentLevel = 1; // Current level
        let practiceMode = false; // Practice mode
        let practiceStartTime = 0; // Practice mode start time
        let gameStartTime = 0; // Game start time

        // Player object
        const player = {
            x: 100,
            y: 300,
            vy: 0, // Vertical velocity
            jumping: false,
            jumpHoldTime: 0, // Time jump is held
            maxJumpHold: 500, // Maximum jump hold time
            width: 30,
            height: 30
        };
        const gravity = 0.8; // Gravity
        const jumpStrength = -12; // Jump strength
        let scrollPosition = 0; // Level scroll position
        let scrollSpeed = 0; // Scroll speed
        let objects = []; // Obstacles and collectibles in the level
        let terrain = []; // Level terrain

        // --- Asset Loading Functions ---

        /**
         * Loads an audio file using Web Audio API.
         * @param {string} url - The URL of the audio file.
         * @returns {Promise<AudioBuffer|null>} A promise that resolves with the AudioBuffer or null on failure.
         */
        async function loadAudio(url) {
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Audio fetch failed: ${response.status} for ${url}`);
                const arrayBuffer = await response.arrayBuffer();
                return await audioContext.decodeAudioData(arrayBuffer);
            } catch (error) {
                console.error('Error loading audio:', error);
                showError(`No se pudo cargar el audio: ${url}. Asegúrate de que la URL sea correcta y accesible.`);
                return null;
            }
        }

        /**
         * Loads an image.
         * @param {string} url - The URL of the image.
         * @returns {Promise<HTMLImageElement>} A promise that resolves with the loaded image.
         */
        function loadImage(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = () => {
                    console.warn(`Failed to load image: ${url}. Using placeholder.`);
                    // Fallback to a placeholder if the image fails to load
                    img.src = `https://placehold.co/${player.width}x${player.height}/cccccc/000000?text=Error`;
                    resolve(img); // Resolve even on error to continue game loading
                };
                img.src = url;
            });
        }

        /**
         * Loads all game assets (audio and images).
         */
        async function loadAssets() {
            console.log('Cargando assets...');
            try {
                // Load audio
                audioBuffer = await loadAudio(audioUrl);
                deathSoundBuffer = await loadAudio(deathSoundUrl);

                // Load images
                sheepImage = await loadImage(sheepImageUrl);
                poopImage = await loadImage(poopImageUrl);
                cheeseImage = await loadImage(cheeseImageUrl);
                eycImage = await loadImage(eycImageUrl);
                estebanImage = await loadImage(estebanImageUrl); // Load new image
                kilyImage = await loadImage(kilyImageUrl);     // Load new image

                console.log('Assets cargados exitosamente');
            } catch (error) {
                console.error('Fallo al cargar assets:', error);
                showError('Error al cargar assets. Revisa la consola y asegúrate de que las URLs de los assets sean correctas y accesibles.');
            }
            menu.style.display = 'block'; // Show main menu once assets are loaded
        }

        /**
         * Displays a temporary error message on the screen.
         * @param {string} msg - The error message to display.
         */
        function showError(msg) {
            errorMessage.textContent = msg;
            errorMessage.style.display = 'block';
            setTimeout(() => errorMessage.style.display = 'none', 5000); // Hide message after 5 seconds
        }

        // --- Audio Control Functions ---

        /**
         * Plays a given AudioBuffer.
         * @param {AudioBuffer} buffer - The audio buffer to play.
         * @returns {AudioBufferSourceNode|null} The created audio source, or null if no buffer.
         */
        function playAudio(buffer) {
            if (buffer) {
                const source = audioContext.createBufferSource();
                source.buffer = buffer;
                source.connect(audioContext.destination);
                source.start(0); // Start playback immediately
                return source;
            }
            return null;
        }

        /**
         * Stops the current background music.
         */
        function stopAudio() {
            if (audioSource) {
                audioSource.stop();
                audioSource = null;
            }
        }

        // --- Particle Functions ---

        /**
         * Creates particles at a specific position with a given color.
         * @param {number} x - X coordinate.
         * @param {number} y - Y coordinate.
         * @param {number} count - Number of particles to create.
         * @param {string} color - Color of the particles (e.g., '#FFFFFF').
         */
        function createParticles(x, y, count, color) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x,
                    y,
                    vx: (Math.random() - 0.5) * 5, // Random X velocity
                    vy: (Math.random() - 0.5) * 5, // Random Y velocity
                    size: 10,
                    alpha: 1, // Initial opacity
                    color,
                    life: 0.5 // Particle life
                });
            }
        }

        // --- Level Generation and Definition ---

        /**
         * Generates level objects based on a template.
         * @param {Array<Object>} baseObjects - Array of base objects.
         * @param {number} scrollSpeed - Level scroll speed.
         * @param {number} duration - Estimated level duration in seconds.
         * @returns {Array<Object>} Array of level objects with adjusted positions.
         */
        function generateLevelObjects(baseObjects, scrollSpeed, duration = 45) { // Default duration to 45 seconds
            const objects = baseObjects.map(obj => ({
                ...obj,
                position: { ...obj.position } // Deep copy of position
            }));
            // Add 'finish' object at the end of the level
            objects.push({ time: duration - 0.1, type: 'finish', position: { x: (duration - 0.1) * scrollSpeed * 60 + 800, y: 300 }, width: 40, height: 100 });
            return objects;
        }

        /**
         * Generates level terrain based on a template and repeats it to cover the duration.
         * @param {Array<Object>} baseTerrain - Array of base terrain segments.
         * @param {number} scrollSpeed - Level scroll speed.
         * @param {number} duration - Estimated level duration in seconds.
         * @returns {Array<Object>} Array of generated terrain segments.
         */
        function generateTerrain(baseTerrain, scrollSpeed, duration = 45) { // Default duration to 45 seconds
            // Calculate the width of one terrain cycle
            const cycleWidth = baseTerrain[baseTerrain.length - 1].x + baseTerrain[baseTerrain.length - 1].width;
            // Calculate the total width required for the level
            const requiredWidth = duration * scrollSpeed * 60; // scrollSpeed * 60 (frames per second)
            // Calculate how many terrain cycles are needed
            const cycles = Math.ceil(requiredWidth / cycleWidth) + 1;
            const terrain = [];
            for (let i = 0; i < cycles; i++) {
                baseTerrain.forEach(seg => {
                    terrain.push({ ...seg, x: seg.x + i * cycleWidth }); // Add segment with cycle offset
                });
            }
            return terrain;
        }

        // Level definitions
        const levels = {
            1: {
                name: 'Facilito',
                scrollSpeed: 8, // Slower speed for easy level
                practicePoints: [0, 10, 20, 30, 40], // Adjusted for 45-second level
                previewColor: '#00FF00',
                baseObjects: [
                    // Level 1: Increased density and varied obstacles
                    { time: 1.0, type: 'fence', position: { x: 800, y: 310 }, width: 40, height: 40 },
                    { time: 1.8, type: 'wool', position: { x: 950, y: 280 }, width: 30, height: 30 },
                    { time: 2.5, type: 'low_fence', position: { x: 1100, y: 320 }, width: 20, height: 30 },
                    { time: 3.2, type: 'cheese', position: { x: 1250, y: 320 }, width: 30, height: 30 }, // Falling cheese
                    { time: 4.0, type: 'spike', position: { x: 1400, y: 330 }, width: 30, height: 20 },
                    { time: 4.8, type: 'fence', position: { x: 1550, y: 310 }, width: 40, height: 40 },
                    { time: 5.6, type: 'low_fence', position: { x: 1700, y: 320 }, width: 20, height: 30 },
                    { time: 6.0, type: 'low_fence', position: { x: 1750, y: 320 }, width: 20, height: 30 }, // Double low fence
                    { time: 7.0, type: 'wool', position: { x: 1950, y: 280 }, width: 30, height: 30 },
                    { time: 7.8, type: 'cheese', position: { x: 2100, y: 320 }, width: 30, height: 30 },
                    { time: 8.6, type: 'spike', position: { x: 2250, y: 330 }, width: 30, height: 20 },
                    { time: 9.4, type: 'fence', position: { x: 2400, y: 310 }, width: 40, height: 40 },
                    { time: 10.2, type: 'low_fence', position: { x: 2550, y: 320 }, width: 20, height: 30 }, // Obstacle at 10s mark
                    { time: 11.0, type: 'cheese', position: { x: 2700, y: 320 }, width: 30, height: 30 },
                    { time: 11.8, type: 'spike', position: { x: 2850, y: 330 }, width: 30, height: 20 },
                    { time: 12.6, type: 'fence', position: { x: 3000, y: 310 }, width: 40, height: 40 },
                    { time: 13.4, type: 'wool', position: { x: 3150, y: 280 }, width: 30, height: 30 },
                    { time: 14.2, type: 'low_fence', position: { x: 3300, y: 320 }, width: 20, height: 30 },
                    { time: 15.0, type: 'cheese', position: { x: 3450, y: 320 }, width: 30, height: 30 },
                    { time: 15.8, type: 'spike', position: { x: 3600, y: 330 }, width: 30, height: 20 },
                    { time: 16.6, type: 'fence', position: { x: 3750, y: 310 }, width: 40, height: 40 },
                    { time: 17.4, type: 'low_fence', position: { x: 3900, y: 320 }, width: 20, height: 30 },
                    { time: 17.8, type: 'low_fence', position: { x: 3950, y: 320 }, width: 20, height: 30 }, // Double low fence
                    { time: 18.6, type: 'wool', position: { x: 4150, y: 280 }, width: 30, height: 30 },
                    { time: 19.4, type: 'cheese', position: { x: 4300, y: 320 }, width: 30, height: 30 },
                    { time: 20.2, type: 'spike', position: { x: 4450, y: 330 }, width: 30, height: 20 },
                    { time: 21.0, type: 'fence', position: { x: 4600, y: 310 }, width: 40, height: 40 },
                    { time: 21.8, type: 'wool', position: { x: 4750, y: 280 }, width: 30, height: 30 },
                    { time: 22.6, type: 'low_fence', position: { x: 4900, y: 320 }, width: 20, height: 30 },
                    { time: 23.4, type: 'cheese', position: { x: 5050, y: 320 }, width: 30, height: 30 },
                    { time: 24.2, type: 'spike', position: { x: 5200, y: 330 }, width: 30, height: 20 },
                    { time: 25.0, type: 'fence', position: { x: 5350, y: 310 }, width: 40, height: 40 },
                    { time: 25.8, type: 'low_fence', position: { x: 5500, y: 320 }, width: 20, height: 30 },
                    { time: 26.2, type: 'low_fence', position: { x: 5550, y: 320 }, width: 20, height: 30 }, // Double low fence
                    { time: 27.0, type: 'wool', position: { x: 5750, y: 280 }, width: 30, height: 30 },
                    { time: 27.8, type: 'cheese', position: { x: 5900, y: 320 }, width: 30, height: 30 },
                    { time: 28.6, type: 'spike', position: { x: 6050, y: 330 }, width: 30, height: 20 },
                    { time: 29.4, type: 'fence', position: { x: 6200, y: 310 }, width: 40, height: 40 },
                    { time: 30.2, type: 'wool', position: { x: 6350, y: 280 }, width: 30, height: 30 },
                    { time: 31.0, type: 'low_fence', position: { x: 6500, y: 320 }, width: 20, height: 30 },
                    { time: 31.8, type: 'cheese', position: { x: 6650, y: 320 }, width: 30, height: 30 },
                    { time: 32.6, type: 'spike', position: { x: 6800, y: 330 }, width: 30, height: 20 },
                    { time: 33.4, type: 'fence', position: { x: 6950, y: 310 }, width: 40, height: 40 },
                    { time: 34.2, type: 'low_fence', position: { x: 7100, y: 320 }, width: 20, height: 30 },
                    { time: 34.6, type: 'low_fence', position: { x: 7150, y: 320 }, width: 20, height: 30 }, // Double low fence
                    { time: 35.4, type: 'wool', position: { x: 7350, y: 280 }, width: 30, height: 30 },
                    { time: 36.2, type: 'cheese', position: { x: 7500, y: 320 }, width: 30, height: 30 },
                    { time: 37.0, type: 'spike', position: { x: 7650, y: 330 }, width: 30, height: 20 },
                    { time: 37.8, type: 'fence', position: { x: 7800, y: 310 }, width: 40, height: 40 },
                    { time: 38.6, type: 'wool', position: { x: 7950, y: 280 }, width: 30, height: 30 },
                    { time: 39.4, type: 'low_fence', position: { x: 8100, y: 320 }, width: 20, height: 30 },
                    { time: 40.2, type: 'cheese', position: { x: 8250, y: 320 }, width: 30, height: 30 },
                    { time: 41.0, type: 'spike', position: { x: 8400, y: 330 }, width: 30, height: 20 },
                    { time: 41.8, type: 'fence', position: { x: 8550, y: 310 }, width: 40, height: 40 },
                    { time: 42.6, type: 'low_fence', position: { x: 8700, y: 320 }, width: 20, height: 30 }
                ],
                baseTerrain: [
                    { x: 0, y: 350, width: 600, height: 50 },
                    { x: 700, y: 320, width: 200, height: 50 }, // Lower platform
                    { x: 950, y: 350, width: 400, height: 50 },
                    { x: 1400, y: 300, width: 300, height: 50 }, // Higher platform
                    { x: 1800, y: 350, width: 600, height: 50 },
                    { x: 2500, y: 320, width: 200, height: 50 },
                    { x: 2800, y: 350, width: 800, height: 50 },
                    { x: 3700, y: 300, width: 300, height: 50 },
                    { x: 4100, y: 350, width: 1000, height: 50 },
                    { x: 5200, y: 320, width: 200, height: 50 },
                    { x: 5500, y: 350, width: 2000, height: 50 },
                    { x: 7600, y: 290, width: 300, height: 50 }, // New higher platform
                    { x: 8000, y: 350, width: 1000, height: 50 },
                    { x: 9200, y: 310, width: 400, height: 50 } // Another varied platform
                ]
            },
            2: {
                name: 'Ataque de Queso',
                scrollSpeed: 10, // Medium speed
                practicePoints: [0, 10, 20, 30, 40], // Adjusted for 45-second level
                previewColor: '#FFD700',
                baseObjects: [
                    { time: 1.0, type: 'cheese', position: { x: 800, y: 320 }, width: 30, height: 30 },
                    { time: 1.3, type: 'cheese', position: { x: 880, y: 320 }, width: 30, height: 30 }, // More consecutive cheese
                    { time: 1.6, type: 'cheese', position: { x: 960, y: 320 }, width: 30, height: 30 },
                    { time: 2.5, type: 'fence', position: { x: 1200, y: 310 }, width: 40, height: 40 },
                    { time: 3.3, type: 'wool', position: { x: 1380, y: 280 }, width: 30, height: 30 },
                    { time: 4.1, type: 'low_fence', position: { x: 1560, y: 320 }, width: 20, height: 30 },
                    { time: 4.9, type: 'spike', position: { x: 1740, y: 330 }, width: 30, height: 20 },
                    { time: 5.7, type: 'blade', position: { x: 1920, y: 320 }, width: 30, height: 30, moving: { type: 'horizontal', range: 100, speed: 5 } }, // Horizontal blade
                    { time: 6.5, type: 'cheese', position: { x: 2100, y: 320 }, width: 30, height: 30 },
                    { time: 6.8, type: 'cheese', position: { x: 2180, y: 320 }, width: 30, height: 30 },
                    { time: 7.1, type: 'cheese', position: { x: 2260, y: 320 }, width: 30, height: 30 },
                    { time: 8.0, type: 'fence', position: { x: 2500, y: 310 }, width: 40, height: 40 },
                    { time: 8.8, type: 'wool', position: { x: 2680, y: 280 }, width: 30, height: 30 },
                    { time: 9.6, type: 'low_fence', position: { x: 2860, y: 320 }, width: 20, height: 30 }, // Obstacle at 10s mark
                    { time: 10.4, type: 'spike', position: { x: 3040, y: 330 }, width: 30, height: 20 },
                    { time: 11.2, type: 'blade', position: { x: 3220, y: 320 }, width: 30, height: 30, moving: { type: 'horizontal', range: 100, speed: 5 } },
                    { time: 12.0, type: 'cheese', position: { x: 3400, y: 320 }, width: 30, height: 30 },
                    { time: 12.3, type: 'cheese', position: { x: 3480, y: 320 }, width: 30, height: 30 },
                    { time: 12.6, type: 'cheese', position: { x: 3560, y: 320 }, width: 30, height: 30 },
                    { time: 13.5, type: 'fence', position: { x: 3800, y: 310 }, width: 40, height: 40 },
                    { time: 14.3, type: 'wool', position: { x: 3980, y: 280 }, width: 30, height: 30 },
                    { time: 15.1, type: 'low_fence', position: { x: 4160, y: 320 }, width: 20, height: 30 },
                    { time: 15.9, type: 'spike', position: { x: 4340, y: 330 }, width: 30, height: 20 },
                    { time: 16.7, type: 'blade', position: { x: 4520, y: 320 }, width: 30, height: 30, moving: { type: 'horizontal', range: 100, speed: 5 } },
                    { time: 17.5, type: 'cheese', position: { x: 4700, y: 320 }, width: 30, height: 30 },
                    { time: 17.8, type: 'cheese', position: { x: 4780, y: 320 }, width: 30, height: 30 },
                    { time: 18.1, type: 'cheese', position: { x: 4860, y: 320 }, width: 30, height: 30 },
                    { time: 19.0, type: 'fence', position: { x: 5100, y: 310 }, width: 40, height: 40 },
                    { time: 19.8, type: 'wool', position: { x: 5280, y: 280 }, width: 30, height: 30 },
                    { time: 20.6, type: 'low_fence', position: { x: 5460, y: 320 }, width: 20, height: 30 },
                    { time: 21.4, type: 'spike', position: { x: 5640, y: 330 }, width: 30, height: 20 },
                    { time: 22.2, type: 'blade', position: { x: 5820, y: 320 }, width: 30, height: 30, moving: { type: 'horizontal', range: 100, speed: 5 } },
                    { time: 23.0, type: 'cheese', position: { x: 6000, y: 320 }, width: 30, height: 30 },
                    { time: 23.3, type: 'cheese', position: { x: 6080, y: 320 }, width: 30, height: 30 },
                    { time: 23.6, type: 'cheese', position: { x: 6160, y: 320 }, width: 30, height: 30 },
                    { time: 24.5, type: 'fence', position: { x: 6400, y: 310 }, width: 40, height: 40 },
                    { time: 25.3, type: 'wool', position: { x: 6580, y: 280 }, width: 30, height: 30 },
                    { time: 26.1, type: 'low_fence', position: { x: 6760, y: 320 }, width: 20, height: 30 },
                    { time: 26.9, type: 'spike', position: { x: 6940, y: 330 }, width: 30, height: 20 },
                    { time: 27.7, type: 'blade', position: { x: 7120, y: 320 }, width: 30, height: 30, moving: { type: 'horizontal', range: 100, speed: 5 } },
                    { time: 28.5, type: 'cheese', position: { x: 7300, y: 320 }, width: 30, height: 30 },
                    { time: 28.8, type: 'cheese', position: { x: 7380, y: 320 }, width: 30, height: 30 },
                    { time: 29.1, type: 'cheese', position: { x: 7460, y: 320 }, width: 30, height: 30 },
                    { time: 30.0, type: 'fence', position: { x: 7700, y: 310 }, width: 40, height: 40 },
                    { time: 30.8, type: 'wool', position: { x: 7880, y: 280 }, width: 30, height: 30 },
                    { time: 31.6, type: 'low_fence', position: { x: 8060, y: 320 }, width: 20, height: 30 },
                    { time: 32.4, type: 'spike', position: { x: 8240, y: 330 }, width: 30, height: 20 },
                    { time: 33.2, type: 'blade', position: { x: 8420, y: 260 }, width: 30, height: 30, moving: { type: 'vertical', range: 60, speed: 3 } }, // Vertical blade
                    { time: 34.0, type: 'cheese', position: { x: 8600, y: 320 }, width: 30, height: 30 },
                    { time: 34.3, type: 'cheese', position: { x: 8680, y: 320 }, width: 30, height: 30 },
                    { time: 34.6, type: 'cheese', position: { x: 8760, y: 320 }, width: 30, height: 30 },
                    { time: 35.5, type: 'fence', position: { x: 9000, y: 310 }, width: 40, height: 40 },
                    { time: 36.3, type: 'wool', position: { x: 9180, y: 280 }, width: 30, height: 30 },
                    { time: 37.1, type: 'low_fence', position: { x: 9360, y: 320 }, width: 20, height: 30 },
                    { time: 37.9, type: 'spike', position: { x: 9540, y: 330 }, width: 30, height: 20 },
                    { time: 38.7, type: 'blade', position: { x: 9720, y: 320 }, width: 30, height: 30, moving: { type: 'horizontal', range: 100, speed: 5 } },
                    { time: 39.5, type: 'cheese', position: { x: 9900, y: 320 }, width: 30, height: 30 },
                    { time: 39.8, type: 'cheese', position: { x: 9980, y: 320 }, width: 30, height: 30 },
                    { time: 40.1, type: 'cheese', position: { x: 10060, y: 320 }, width: 30, height: 30 }
                ],
                baseTerrain: [
                    { x: 0, y: 350, width: 300, height: 50 },
                    { x: 400, y: 300, width: 200, height: 50 },
                    { x: 700, y: 350, width: 200, height: 50 },
                    { x: 1000, y: 310, width: 150, height: 40 },
                    { x: 1200, y: 350, width: 500, height: 50 },
                    { x: 1800, y: 300, width: 200, height: 50 },
                    { x: 2100, y: 350, width: 600, height: 50 },
                    { x: 2800, y: 320, width: 200, height: 50 },
                    { x: 3100, y: 350, width: 800, height: 50 },
                    { x: 4000, y: 300, width: 300, height: 50 },
                    { x: 4400, y: 350, width: 2000, height: 50 },
                    { x: 6500, y: 280, width: 400, height: 50 }, // New higher platform
                    { x: 7000, y: 350, width: 1000, height: 50 },
                    { x: 8200, y: 310, width: 500, height: 50 }, // Another varied platform
                    { x: 8800, y: 350, width: 1500, height: 50 }
                ]
            },
            3: {
                name: 'Imposible',
                scrollSpeed: 12, // Fast speed
                practicePoints: [0, 10, 20, 30, 40], // Adjusted for 45-second level
                previewColor: '#FF0000',
                baseObjects: [
                    // Level 3: Easier but still challenging, with springs
                    { time: 1.0, type: 'low_fence', position: { x: 800, y: 320 }, width: 20, height: 30 },
                    { time: 1.8, type: 'spike', position: { x: 950, y: 330 }, width: 30, height: 20 },
                    { time: 2.5, type: 'fence', position: { x: 1100, y: 310 }, width: 40, height: 40 },
                    { time: 3.2, type: 'spring', position: { x: 1250, y: 330 }, width: 30, height: 20 }, // Spring!
                    { time: 4.0, type: 'wool', position: { x: 1400, y: 200 }, width: 30, height: 30 }, // Wool high up
                    { time: 4.8, type: 'blade', position: { x: 1550, y: 260 }, width: 30, height: 30, moving: { type: 'vertical', range: 80, speed: 4 } },
                    { time: 5.6, type: 'low_fence', position: { x: 1700, y: 320 }, width: 20, height: 30 },
                    { time: 6.4, type: 'cheese', position: { x: 1850, y: 320 }, width: 30, height: 30 },
                    { time: 7.2, type: 'spike', position: { x: 2000, y: 330 }, width: 30, height: 20 },
                    { time: 8.0, type: 'fence', position: { x: 2150, y: 310 }, width: 40, height: 40 },
                    { time: 8.8, type: 'spring', position: { x: 2300, y: 330 }, width: 30, height: 20 }, // Another spring
                    { time: 9.6, type: 'wool', position: { x: 2450, y: 180 }, width: 30, height: 30 },
                    { time: 10.4, type: 'blade', position: { x: 2600, y: 320 }, width: 30, height: 30, moving: { type: 'horizontal', range: 100, speed: 6 } },
                    { time: 11.2, type: 'low_fence', position: { x: 2750, y: 320 }, width: 20, height: 30 },
                    { time: 12.0, type: 'cheese', position: { x: 2900, y: 320 }, width: 30, height: 30 },
                    { time: 12.8, type: 'spike', position: { x: 3050, y: 330 }, width: 30, height: 20 },
                    { time: 13.6, type: 'fence', position: { x: 3200, y: 310 }, width: 40, height: 40 },
                    { time: 14.4, type: 'spring', position: { x: 3350, y: 330 }, width: 30, height: 20 },
                    { time: 15.2, type: 'wool', position: { x: 3500, y: 200 }, width: 30, height: 30 },
                    { time: 16.0, type: 'blade', position: { x: 3650, y: 260 }, width: 30, height: 30, moving: { type: 'vertical', range: 80, speed: 4 } },
                    { time: 16.8, type: 'low_fence', position: { x: 3800, y: 320 }, width: 20, height: 30 },
                    { time: 17.6, type: 'cheese', position: { x: 3950, y: 320 }, width: 30, height: 30 },
                    { time: 18.4, type: 'spike', position: { x: 4100, y: 330 }, width: 30, height: 20 },
                    { time: 19.2, type: 'fence', position: { x: 4250, y: 310 }, width: 40, height: 40 },
                    { time: 20.0, type: 'spring', position: { x: 4400, y: 330 }, width: 30, height: 20 },
                    { time: 20.8, type: 'wool', position: { x: 4550, y: 180 }, width: 30, height: 30 },
                    { time: 21.6, type: 'blade', position: { x: 4700, y: 320 }, width: 30, height: 30, moving: { type: 'horizontal', range: 100, speed: 6 } },
                    { time: 22.4, type: 'low_fence', position: { x: 4850, y: 320 }, width: 20, height: 30 },
                    { time: 23.2, type: 'cheese', position: { x: 5000, y: 320 }, width: 30, height: 30 },
                    { time: 24.0, type: 'spike', position: { x: 5150, y: 330 }, width: 30, height: 20 },
                    { time: 24.8, type: 'fence', position: { x: 5300, y: 310 }, width: 40, height: 40 },
                    { time: 25.6, type: 'spring', position: { x: 5450, y: 330 }, width: 30, height: 20 },
                    { time: 26.4, type: 'wool', position: { x: 5600, y: 200 }, width: 30, height: 30 },
                    { time: 27.2, type: 'blade', position: { x: 5750, y: 260 }, width: 30, height: 30, moving: { type: 'vertical', range: 80, speed: 4 } },
                    { time: 28.0, type: 'low_fence', position: { x: 5900, y: 320 }, width: 20, height: 30 },
                    { time: 28.8, type: 'cheese', position: { x: 6050, y: 320 }, width: 30, height: 30 },
                    { time: 29.6, type: 'spike', position: { x: 6200, y: 330 }, width: 30, height: 20 },
                    { time: 30.4, type: 'fence', position: { x: 6350, y: 310 }, width: 40, height: 40 },
                    { time: 31.2, type: 'spring', position: { x: 6500, y: 330 }, width: 30, height: 20 },
                    { time: 32.0, type: 'wool', position: { x: 6650, y: 180 }, width: 30, height: 30 },
                    { time: 32.8, type: 'blade', position: { x: 6800, y: 320 }, width: 30, height: 30, moving: { type: 'horizontal', range: 100, speed: 6 } },
                    { time: 33.6, type: 'low_fence', position: { x: 6950, y: 320 }, width: 20, height: 30 },
                    { time: 34.4, type: 'cheese', position: { x: 7100, y: 320 }, width: 30, height: 30 },
                    { time: 35.2, type: 'spike', position: { x: 7250, y: 330 }, width: 30, height: 20 },
                    { time: 36.0, type: 'fence', position: { x: 7400, y: 310 }, width: 40, height: 40 },
                    { time: 36.8, type: 'spring', position: { x: 7550, y: 330 }, width: 30, height: 20 },
                    { time: 37.6, type: 'wool', position: { x: 7700, y: 200 }, width: 30, height: 30 },
                    { time: 38.4, type: 'blade', position: { x: 7850, y: 260 }, width: 30, height: 30, moving: { type: 'vertical', range: 80, speed: 4 } },
                    { time: 39.2, type: 'low_fence', position: { x: 8000, y: 320 }, width: 20, height: 30 },
                    { time: 40.0, type: 'cheese', position: { x: 8150, y: 320 }, width: 30, height: 30 },
                    { time: 40.8, type: 'spike', position: { x: 8300, y: 330 }, width: 30, height: 20 },
                    { time: 41.6, type: 'fence', position: { x: 8450, y: 310 }, width: 40, height: 40 },
                    { time: 42.4, type: 'spring', position: { x: 8600, y: 330 }, width: 30, height: 20 }
                ],
                baseTerrain: [
                    { x: 0, y: 350, width: 200, height: 50 },
                    { x: 250, y: 300, width: 150, height: 50 }, // Lower platform
                    { x: 450, y: 270, width: 100, height: 20 }, // Intermediate platform higher
                    { x: 600, y: 240, width: 150, height: 50 }, // Even higher platform
                    { x: 800, y: 310, width: 100, height: 40 }, // Another intermediate platform
                    { x: 950, y: 350, width: 200, height: 50 },
                    { x: 1200, y: 300, width: 150, height: 50 },
                    { x: 1400, y: 350, width: 600, height: 50 },
                    { x: 2100, y: 320, width: 200, height: 50 },
                    { x: 2400, y: 350, width: 800, height: 50 },
                    { x: 3300, y: 300, width: 300, height: 50 },
                    { x: 3700, y: 350, width: 2000, height: 50 },
                    { x: 5800, y: 260, width: 500, height: 50 }, // Elevated platform for a long jump
                    { x: 6400, y: 350, width: 800, height: 50 },
                    { x: 7300, y: 310, width: 400, height: 50 }, // Another varied platform
                    { x: 7800, y: 350, width: 1200, height: 50 },
                    { x: 9100, y: 290, width: 600, height: 50 } // Final elevated platform
                ]
            }
        };

        // Generates objects and terrain for each level at startup
        for (let level in levels) {
            levels[level].objects = generateLevelObjects(levels[level].baseObjects, levels[level].scrollSpeed, 45); // Pass 45 seconds duration
            levels[level].terrain = generateTerrain(levels[level].baseTerrain, levels[level].scrollSpeed, 45); // Pass 45 seconds duration
        }

        // --- Main Game Loop ---

        /**
         * Main game loop that runs every frame.
         * @param {DOMHighResTimeStamp} timestamp - The current time provided by requestAnimationFrame.
         */
        function gameLoop(timestamp) {
            if (!gameRunning || isPaused) return; // If game is not running or paused, do nothing
            update(timestamp); // Update game logic
            render(); // Draw the game
            requestAnimationFrame(gameLoop); // Request next frame
        }

        /**
         * Updates the game state every frame.
         * @param {DOMHighResTimeStamp} timestamp - The current time.
         */
        function update(timestamp) {
            // Update player jump
            updateJump();
            // Apply gravity
            player.vy += gravity;
            player.y += player.vy;

            let onGround = false;
            let currentSegment = null;

            // Collision detection with terrain
            for (let segment of terrain) {
                const segX = segment.x - scrollPosition;
                // If player is on a terrain segment
                if (player.x + player.width > segX && player.x < segX + segment.width &&
                    player.y + player.height > segment.y && player.y + player.height <= segment.y + player.vy + 10) {
                    player.y = segment.y - player.height; // Place player on terrain
                    player.vy = 0; // Stop falling
                    player.jumping = false; // Not jumping anymore
                    player.jumpHoldTime = 0; // Reset jump time
                    onGround = true; // Player is on the ground
                    break;
                }
                // Identify the current terrain segment below the player
                if (player.x + player.width > segX && player.x < segX + segment.width) {
                    currentSegment = segment;
                }
            }

            // If player is not on the ground and falls below a terrain segment
            if (!onGround && currentSegment && player.y + player.height > currentSegment.y) {
                let hasLowerSegment = false;
                // Check if there's a lower terrain segment to fall onto
                for (let segment of terrain) {
                    const segX = segment.x - scrollPosition;
                    if (player.x + player.width > segX && player.x < segX + segment.width &&
                        segment.y > currentSegment.y && player.y + player.height >= segment.y) {
                        hasLowerSegment = true;
                        break;
                    }
                }
                // If no lower segment, player "dies" by falling
                if (!hasLowerSegment) {
                    handleDeath();
                    return;
                }
            }

            // If player falls below the canvas (off-screen)
            if (!onGround && player.y > canvas.height) { // Adjusted to canvas.height for clearer death
                handleDeath();
                return;
            }

            // Limit player from going off the top
            if (player.y < 0) {
                player.y = 0;
                player.vy = 0;
            }

            // Scroll the level
            scrollPosition += scrollSpeed;

            // Logic to add objects to the game based on elapsed time
            const currentTime = audioBuffer ? audioContext.currentTime - audioStartTime + practiceStartTime : timestamp / 1000;
            // Filter out objects that have already passed the screen
            objects = objects.filter(obj => obj.position.x - scrollPosition > -100);
            levels[currentLevel].objects.forEach(event => {
                // If event time has arrived and object is not already in the list
                if (currentTime >= event.time && !objects.includes(event)) {
                    const newObj = { ...event, position: { ...event.position } };
                    if (newObj.type === 'cheese') {
                        newObj.currentY = 0; // Start from top for falling effect
                        newObj.targetY = newObj.position.y;
                        newObj.fallSpeed = 5;
                        newObj.falling = true;
                    } else {
                        newObj.currentY = newObj.position.y; // Normal position
                    }
                    // Prevent too many cheeses from falling at once
                    if (newObj.type === 'cheese' && objects.filter(o => o.type === 'cheese' && o.falling).length >= 1) {
                        return;
                    }
                    objects.push(newObj);
                }
            });

            // Update position of moving and falling objects
            objects.forEach(obj => {
                if (obj.falling) {
                    obj.currentY += obj.fallSpeed;
                    if (obj.currentY >= obj.targetY) {
                        obj.currentY = obj.targetY;
                        obj.falling = false;
                    }
                }
                if (!obj.falling && obj.moving) {
                    if (obj.moving.type === 'vertical') {
                        obj.currentY += obj.moving.speed;
                        // Reverse direction if it reaches range limits
                        if (obj.currentY > obj.position.y || obj.currentY < obj.position.y - obj.moving.range) {
                            obj.moving.speed = -obj.moving.speed;
                        }
                    } else if (obj.moving.type === 'horizontal') {
                        obj.position.x += obj.moving.speed;
                        // Reverse direction if it reaches range limits (adjusted so object moves within its initial position and a range)
                        if (obj.position.x > obj.position.x + obj.moving.range || obj.position.x < obj.position.x) {
                            obj.moving.speed = -obj.moving.speed;
                        }
                    }
                }
            });

            // Update particle position and opacity
            particles = particles.filter(p => p.alpha > 0);
            particles.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.alpha -= 0.02; // Fade out particles
                p.size *= 0.98; // Reduce size
            });

            // Player collision detection with objects
            objects.forEach((obj, index) => {
                const objX = obj.position.x - scrollPosition;
                if (objX < -50 || objX > canvas.width) return; // If object is off-screen, ignore

                const objLeft = objX;
                const objRight = objX + obj.width;
                const objTop = obj.currentY || obj.position.y;
                const objBottom = objTop + obj.height;

                const playerLeft = player.x;
                const playerRight = player.x + player.width;
                const playerTop = player.y;
                const playerBottom = player.y + player.height;

                // If collision
                if (playerRight > objLeft && playerLeft < objRight && playerBottom > objTop && playerTop < objBottom) {
                    if (obj.type === 'wool') {
                        coins += 25; // Each wool is now worth 25 coins
                        localStorage.setItem('coins', coins); // Save to localStorage
                        coinDisplays.forEach(display => {
                            display.textContent = coins;
                            display.classList.add('highlight'); // Highlight coin
                            setTimeout(() => display.classList.remove('highlight'), 500);
                        });
                        createParticles(objX + obj.width / 2, objTop + obj.height / 2, 5, '#FFFFFF'); // Wool particles
                        objects.splice(index, 1); // Remove wool
                    } else if (obj.type === 'spring') {
                        player.vy = jumpStrength * 1.8; // Boost player significantly
                        player.jumping = true; // Set jumping state to true to allow jump mechanics to take over
                        player.jumpHoldTime = 0; // Reset jump hold time
                        createParticles(objX + obj.width / 2, objTop, 10, '#00FF00'); // Green particles for spring
                        objects.splice(index, 1); // Remove spring after use
                    }
                    else if (obj.type === 'finish') {
                        // Level completed
                        gameRunning = false;
                        stopAudio(); // Stop music
                        const finalTime = (performance.now() - gameStartTime) / 1000;
                        document.getElementById('completionTime').textContent = `Tiempo: ${finalTime.toFixed(1)}s`;
                        levelComplete.style.display = 'block'; // Show level complete screen
                        pauseButton.style.display = 'none';
                        objects = []; // Clear objects
                    } else {
                        // Collision with obstacle (death)
                        handleDeath();
                    }
                }
            });
        }

        /**
         * Draws all game elements on the canvas.
         */
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas
            // console.log('Rendering frame'); // For debugging

            // Draw sky and grass (canvas background)
            const skyHeight = canvas.height * 0.6; // 60% sky
            const grassHeight = canvas.height * 0.4; // 40% grass
            
            // Sky
            ctx.fillStyle = '#87CEEB'; // Sky blue
            ctx.fillRect(0, 0, canvas.width, skyHeight);

            // Grass
            ctx.fillStyle = '#a8e4a0'; // Grass green
            ctx.fillRect(0, skyHeight, canvas.width, grassHeight);

            // Draw terrain
            ctx.fillStyle = '#8B4513'; // Earth color
            terrain.forEach(segment => {
                const x = segment.x - scrollPosition;
                if (x + segment.width > 0 && x < canvas.width) {
                    ctx.fillRect(x, segment.y, segment.width, segment.height);
                }
            });

            // Draw objects (obstacles and collectibles)
            objects.forEach(obj => {
                const x = obj.position.x - scrollPosition;
                if (x < -50 || x > canvas.width) return; // If object is off-screen, don't draw
                const y = obj.currentY || obj.position.y;

                switch (obj.type) {
                    case 'cheese':
                        if (cheeseImage) {
                            ctx.drawImage(cheeseImage, x, y, obj.width, obj.height);
                        } else {
                            ctx.fillStyle = '#FFD700'; // Cheese color if no image
                            ctx.fillRect(x, y, obj.width, obj.height);
                        }
                        break;
                    case 'fence':
                        ctx.fillStyle = '#8B5A2B'; // Fence color
                        ctx.fillRect(x, y, obj.width, obj.height);
                        break;
                    case 'low_fence': // New obstacle type
                        ctx.fillStyle = '#6B4226'; // Slightly different color to distinguish
                        ctx.fillRect(x, y, obj.width, obj.height);
                        break;
                    case 'spike': // Spikes
                        ctx.fillStyle = '#FF0000'; // Spike color
                        ctx.beginPath();
                        ctx.moveTo(x, y + obj.height);
                        ctx.lineTo(x + obj.width / 2, y);
                        ctx.lineTo(x + obj.width, y + obj.height);
                        ctx.fill();
                        break;
                    case 'blade':
                        ctx.fillStyle = '#C0C0C0'; // Blade color
                        ctx.beginPath();
                        ctx.arc(x + obj.width / 2, y + obj.height / 2, obj.width / 2, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 'wool':
                        ctx.fillStyle = '#FFFFFF'; // Wool color
                        ctx.beginPath();
                        ctx.arc(x + obj.width / 2, y + obj.height / 2, obj.width / 2, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 'spring': // Draw spring
                        ctx.fillStyle = '#00FF00'; // Green for spring
                        ctx.fillRect(x, y, obj.width, obj.height);
                        ctx.fillStyle = '#000000';
                        ctx.font = '10px Arial';
                        ctx.fillText('↑', x + obj.width / 2 - 4, y + obj.height / 2 + 4); // Arrow for spring
                        break;
                    case 'finish':
                        ctx.fillStyle = '#00FF00'; // Finish line color
                        ctx.fillRect(x, y, obj.width, obj.height);
                        break;
                }
            });

            // Draw particles
            particles.forEach(p => {
                ctx.fillStyle = `rgba(${parseInt(p.color.slice(1, 3), 16)}, ${parseInt(p.color.slice(3, 5), 16)}, ${parseInt(p.color.slice(5, 7), 16)}, ${p.alpha})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size / 2, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw player (using image or color based on selected character)
            if (currentCharacter.isImage && currentCharacter.imageUrl) {
                let charImage = null;
                switch (currentCharacter.name) {
                    case 'Sheep': charImage = sheepImage; break;
                    case 'Poop': charImage = poopImage; break;
                    case 'Lion': charImage = estebanImage; break; // Use estebanImage
                    case 'Penguin': charImage = kilyImage; break;     // Use kilyImage
                    case 'Dragon': charImage = eycImage; break;
                }
                if (charImage) {
                    ctx.drawImage(charImage, player.x, player.y, player.width, player.height);
                } else {
                    // Fallback to color if image fails to load
                    ctx.fillStyle = currentCharacter.color;
                    ctx.fillRect(player.x, player.y, player.width, player.height);
                }
            } else {
                ctx.fillStyle = currentCharacter.color;
                ctx.fillRect(player.x, player.y, player.width, player.height);
            }

            // Draw level text, time, and progress
            ctx.fillStyle = 'black';
            ctx.font = '16px Arial';
            const currentTime = gameRunning ? (performance.now() - gameStartTime) / 1000 : 0;
            const totalLevelWidth = levels[currentLevel].scrollSpeed * 60 * 45; // Total level width based on 45 seconds duration
            const progressPercentage = Math.min(100, (scrollPosition / totalLevelWidth) * 100).toFixed(1);
            ctx.fillText(`Nivel: ${levels[currentLevel].name} | Tiempo: ${currentTime.toFixed(1)}s | Progreso: ${progressPercentage}%`, 10, 20);
        }

        // --- Player Control Functions ---

        /**
         * Handles player jump logic.
         */
        function updateJump() {
            if (player.jumping && player.jumpHoldTime < player.maxJumpHold) {
                player.vy = jumpStrength * (1 - player.jumpHoldTime / player.maxJumpHold);
                player.jumpHoldTime += 16; // Assumes 60 FPS (1000ms / 60 frames = ~16ms per frame)
            }
        }

        /**
         * Handles player death.
         */
        function handleDeath() {
            gameRunning = false;
            stopAudio(); // Stop background music
            playAudio(deathSoundBuffer); // Play death sound
            showError('¡Has muerto! Inténtalo de nuevo.');
            returnToMenu(); // Return to main menu
            objects = []; // Clear objects for next game
            particles = []; // Clear particles
        }

        // --- Menu and Game Control Functions ---

        /**
         * Starts the game with the specified level.
         * @param {number} levelId - The ID of the level to start.
         */
        function startGame(levelId) {
            // Ensure AudioContext is not suspended (needed due to browser autoplay policies)
            if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    console.log('AudioContext reanudado');
                    startAudioAndGame(levelId);
                }).catch(e => {
                    console.error('Error al reanudar AudioContext:', e);
                    showError('No se pudo iniciar el audio. Por favor, interactúa con la página.');
                    startAudioAndGame(levelId); // Try to start game without audio if it fails
                });
            } else {
                startAudioAndGame(levelId);
            }
        }

        /**
         * Helper function to start audio and game after AudioContext resumption.
         * @param {number} levelId - The ID of the level to start.
         */
        function startAudioAndGame(levelId) {
            stopAudio(); // Stop any previous audio
            if (audioBuffer) { // If background audio loaded successfully
                audioSource = playAudio(audioBuffer); // Start background music
                if (audioSource) {
                    audioSource.loop = true; // Make music loop
                    audioStartTime = audioContext.currentTime; // Save start time for practice mode
                }
            }

            currentLevel = levelId;
            scrollPosition = 0;
            // Reset player position and state
            player.x = 100;
            player.y = 300;
            player.vy = 0;
            player.jumping = false;
            player.jumpHoldTime = 0;
            objects = []; // Reset level objects
            terrain = levels[currentLevel].terrain; // Load level terrain
            scrollSpeed = levels[currentLevel].scrollSpeed; // Set level scroll speed

            // Hide all menus and show pause button
            menu.style.display = 'none';
            levelSelect.style.display = 'none';
            pauseMenu.style.display = 'none';
            characterMenu.style.display = 'none';
            levelComplete.style.display = 'none';
            pauseButton.style.display = 'flex'; // Use flex to center "II" text

            gameRunning = true;
            isPaused = false;
            gameStartTime = performance.now(); // Save game start time
            requestAnimationFrame(gameLoop); // Start game loop
        }

        /**
         * Resumes the game from the pause menu.
         */
        function resumeGame() {
            isPaused = false;
            pauseMenu.style.display = 'none';
            pauseButton.style.display = 'flex'; // Show pause button
            if (audioContext.state === 'suspended') {
                audioContext.resume(); // Resume AudioContext if suspended
            }
            if (audioSource) {
                // If audioSource exists and is not playing (because it was suspended), resume it
                // Web Audio API handles resumption automatically when AudioContext is resumed
            }
            requestAnimationFrame(gameLoop); // Resume game loop
        }

        /**
         * Toggles the game pause state.
         */
        function togglePause() {
            isPaused = !isPaused;
            if (isPaused) {
                pauseMenu.style.display = 'block'; // Show pause menu
                pauseButton.style.display = 'none'; // Hide pause button
                if (audioContext.state === 'running') {
                    audioContext.suspend(); // Suspende el AudioContext para pausar el audio
                }
            } else {
                resumeGame(); // Reanuda el juego
            }
        }

        /**
         * Shows the level selection menu.
         */
        function showLevelSelect() {
            menu.style.display = 'none';
            levelSelect.style.display = 'block';
            updateCoinDisplays();
            renderLevelList();
        }

        /**
         * Shows the character selection menu.
         */
        function showCharacters() {
            menu.style.display = 'none';
            pauseMenu.style.display = 'none'; // Also from pause
            characterMenu.style.display = 'block';
            updateCoinDisplays();
            renderCharacterList();
        }

        /**
         * Returns to the main menu from any other menu.
         */
        function returnToMenu() {
            gameRunning = false; // Stop game if running
            isPaused = false;
            stopAudio(); // Stop any background audio
            menu.style.display = 'block';
            levelSelect.style.display = 'none';
            pauseMenu.style.display = 'none';
            characterMenu.style.display = 'none';
            levelComplete.style.display = 'none';
            pauseButton.style.display = 'none';
            updateCoinDisplays();
        }

        /**
         * Toggles practice mode.
         */
        function togglePractice() {
            practiceMode = !practiceMode;
            // Logic for practice mode (e.g., invincibility or save points)
            // Not fully implemented in this example, but can be added here.
            showError(`Modo Práctica: ${practiceMode ? 'Activado' : 'Desactivado'}`);
        }

        /**
         * Updates coin text in all displays.
         */
        function updateCoinDisplays() {
            coinDisplays.forEach(display => display.textContent = coins);
        }

        /**
         * Renders the list of levels in the level selection menu.
         */
        function renderLevelList() {
            const levelListDiv = document.getElementById('levelList');
            levelListDiv.innerHTML = ''; // Clear existing list
            for (let id in levels) {
                const level = levels[id];
                const levelDiv = document.createElement('div');
                levelDiv.className = 'level-preview';
                levelDiv.style.backgroundColor = level.previewColor;
                levelDiv.textContent = level.name;
                levelDiv.onclick = () => startGame(parseInt(id)); // Start game on click
                levelListDiv.appendChild(levelDiv);
            }
        }

        /**
         * Renders the list of characters in the character selection menu.
         */
        function renderCharacterList() {
            const characterListDiv = document.getElementById('characterList');
            characterListDiv.innerHTML = ''; // Clear existing list

            characters.forEach(char => {
                const charOption = document.createElement('div');
                charOption.className = 'character-option';
                if (char.name === currentCharacter.name) {
                    charOption.classList.add('selected');
                }

                if (char.isImage && char.imageUrl) {
                    const img = document.createElement('img');
                    img.src = char.imageUrl;
                    img.alt = char.name;
                    charOption.appendChild(img);
                } else {
                    const colorBox = document.createElement('div');
                    colorBox.className = 'character-color-box';
                    colorBox.style.backgroundColor = char.color;
                    charOption.appendChild(colorBox);
                }

                const nameP = document.createElement('p');
                nameP.textContent = char.name;
                charOption.appendChild(nameP);

                if (char.unlocked) {
                    const selectButton = document.createElement('button');
                    selectButton.textContent = 'Seleccionar';
                    selectButton.onclick = () => {
                        currentCharacter = char;
                        renderCharacterList(); // Re-render to update selection
                    };
                    selectButton.disabled = (char.name === currentCharacter.name);
                    charOption.appendChild(selectButton);
                } else {
                    const costP = document.createElement('p');
                    costP.className = 'cost';
                    costP.textContent = `Costo: ${char.cost} Monedas`;
                    charOption.appendChild(costP);

                    const buyButton = document.createElement('button');
                    buyButton.textContent = 'Comprar';
                    buyButton.disabled = (coins < char.cost);
                    buyButton.onclick = () => {
                        if (coins >= char.cost) {
                            coins -= char.cost;
                            char.unlocked = true;
                            localStorage.setItem('coins', coins);
                            const currentSavedChars = localStorage.getItem('characters') ? JSON.parse(localStorage.getItem('characters')) : [];
                            currentSavedChars.push(char.name);
                            localStorage.setItem('characters', JSON.stringify(currentSavedChars));
                            updateCoinDisplays();
                            renderCharacterList(); // Re-render to update
                            showError(`¡${char.name} desbloqueado!`);
                        } else {
                            showError('¡No tienes suficientes monedas!');
                        }
                    };
                    charOption.appendChild(buyButton);
                }
                characterListDiv.appendChild(charOption);
            });
        }

        // --- Event Listeners ---

        // Handle jump with spacebar
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && gameRunning && !isPaused && !player.jumping) {
                player.jumping = true;
                player.jumpHoldTime = 0;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space' && gameRunning && !isPaused && player.jumping) {
                player.jumping = false;
            }
        });

        // Handle jump with mouse click on canvas
        canvas.addEventListener('mousedown', (e) => {
            if (gameRunning && !isPaused && !player.jumping) {
                player.jumping = true;
                player.jumpHoldTime = 0;
            }
        });

        // Event to start loading assets when window is fully loaded
        window.onload = function () {
            loadAssets();
        };

    </script>
</body>
</html>
