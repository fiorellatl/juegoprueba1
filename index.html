<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Capybara Dash - Juego</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: #f0f0f0;
            font-family: 'Inter', Arial, sans-serif; /* Usando Inter como fuente principal */
        }
        #gameCanvas {
            border: 1px solid #000;
            background: linear-gradient(to bottom, #87CEEB, #a8e4a0); /* Cielo y pasto */
            border-radius: 10px; /* Bordes redondeados */
            box-shadow: 0 0 15px rgba(0,0,0,0.4); /* Sombra para el canvas */
        }
        #menu, #pauseMenu, #levelSelect, #characterMenu, #levelComplete {
            position: absolute;
            background: rgba(255, 255, 255, 0.95); /* Fondo ligeramente más opaco */
            padding: 30px; /* Más padding */
            border-radius: 15px; /* Más redondeado */
            text-align: center;
            display: none;
            box-shadow: 0 0 20px rgba(0,0,0,0.4); /* Sombra más pronunciada */
            border: 2px solid #4CAF50; /* Borde verde */
        }
        h2 {
            color: #333;
            margin-top: 0;
            font-size: 2em;
        }
        button {
            padding: 12px 25px; /* Más padding */
            margin: 8px; /* Más margen */
            cursor: pointer;
            background: linear-gradient(to bottom, #4CAF50, #45a049); /* Degradado */
            color: white;
            border: none;
            border-radius: 8px; /* Más redondeado */
            font-size: 18px; /* Fuente más grande */
            font-weight: bold;
            transition: all 0.3s ease; /* Transición suave */
            box-shadow: 0 4px 6px rgba(0,0,0,0.2); /* Sombra para botones */
        }
        button:hover {
            background: linear-gradient(to bottom, #45a049, #3e8e41);
            transform: translateY(-2px); /* Efecto de elevación */
            box-shadow: 0 6px 8px rgba(0,0,0,0.3);
        }
        button:active {
            transform: translateY(1px); /* Efecto de clic */
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        button:disabled {
            background: #cccccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        #coinDisplay, #coinDisplayPause, #coinDisplayLevel, #coinDisplayCharacter {
            font-weight: bold;
            font-size: 1.2em;
            color: #555;
            transition: color 0.5s;
        }
        .highlight {
            color: #FFD700; /* Color de oro para resaltar monedas */
            text-shadow: 0 0 5px rgba(255,215,0,0.7);
        }
        #levelComplete h2 {
            font-size: 28px;
            color: #4CAF50;
        }
        #levelComplete p {
            font-size: 20px;
            color: #333;
        }
        .level-preview {
            width: 120px; /* Más grande */
            height: 70px; /* Más grande */
            margin: 12px;
            display: inline-block;
            border: 3px solid #333; /* Borde más grueso */
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .level-preview:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        .character-option {
            display: inline-block;
            margin: 15px;
            padding: 10px;
            border: 2px solid #ccc;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }
        .character-option.selected {
            border-color: #4CAF50;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
            background-color: #e6ffe6;
        }
        .character-option:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 10px rgba(0,0,0,0.2);
        }
        .character-option img {
            width: 60px;
            height: 60px;
            border-radius: 5px;
            margin-bottom: 5px;
        }
        .character-option .character-color-box {
            width: 60px;
            height: 60px;
            border-radius: 5px;
            margin: 0 auto 5px auto;
            border: 1px solid #eee;
        }
        .character-option p {
            margin: 0;
            font-weight: bold;
            color: #333;
        }
        .character-option .cost {
            font-size: 0.9em;
            color: #777;
        }
        .character-option button {
            margin-top: 10px;
            padding: 8px 15px;
            font-size: 14px;
        }

        #pauseButton {
            position: absolute;
            top: 20px; /* Más margen */
            left: 50%;
            transform: translateX(-50%);
            width: 40px; /* Más grande */
            height: 40px; /* Más grande */
            background: #FF0000;
            border-radius: 50%;
            cursor: pointer;
            display: none;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            transition: background 0.3s ease;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: white;
            font-weight: bold;
        }
        #pauseButton:hover {
            background: #CC0000;
        }
        #errorMessage {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 0, 0, 0.9);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            display: none;
            box-shadow: 0 0 10px rgba(255,0,0,0.5);
            font-weight: bold;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="400"></canvas>

    <div id="menu">
        <h2>Capybara Dash</h2>
        <button onclick="startGame(1)">Jugar</button>
        <button onclick="showLevelSelect()">Seleccionar Nivel</button>
        <button onclick="showCharacters()">Seleccionar Personaje</button>
        <button onclick="togglePractice()">Modo Práctica</button>
        <p>Monedas: <span id="coinDisplay">0</span></p>
    </div>

    <div id="levelSelect">
        <h2>Seleccionar Nivel</h2>
        <div id="levelList"></div>
        <button onclick="returnToMenu()">Volver</button>
        <p>Monedas: <span id="coinDisplayLevel">0</span></p>
    </div>

    <div id="pauseMenu">
        <h2>Pausado</h2>
        <button onclick="resumeGame()">Reanudar</button>
        <button onclick="togglePractice()">Modo Práctica</button>
        <button onclick="showCharacters()">Seleccionar Personaje</button>
        <button onclick="returnToMenu()">Menú Principal</button>
        <p>Monedas: <span id="coinDisplayPause">0</span></p>
    </div>

    <div id="characterMenu">
        <h2>Seleccionar Personaje</h2>
        <div id="characterList"></div>
        <button onclick="returnToMenu()">Volver</button>
        <p>Monedas: <span id="coinDisplayCharacter">0</span></p>
    </div>

    <div id="levelComplete">
        <h2>¡Buena, Capybara! ¡Lo lograste!</h2>
        <p id="completionTime"></p>
        <button onclick="returnToMenu()">Menú Principal</button>
    </div>

    <div id="pauseButton" onclick="togglePause()">II</div>

    <div id="errorMessage"></div>

    <script>
        // --- Global Variables and DOM Elements ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const menu = document.getElementById('menu');
        const levelSelect = document.getElementById('levelSelect');
        const pauseMenu = document.getElementById('pauseMenu');
        const characterMenu = document.getElementById('characterMenu');
        const levelComplete = document.getElementById('levelComplete');
        const pauseButton = document.getElementById('pauseButton');
        const errorMessage = document.getElementById('errorMessage');

        // Player coins, loaded from localStorage or initialized to 0
        let coins = localStorage.getItem('coins') ? parseInt(localStorage.getItem('coins')) : 0;
        const coinDisplays = [
            document.getElementById('coinDisplay'),
            document.getElementById('coinDisplayPause'),
            document.getElementById('coinDisplayLevel'),
            document.getElementById('coinDisplayCharacter')
        ];
        // Update coin display in all locations
        coinDisplays.forEach(display => display.textContent = coins);

        // Character definitions
        const characters = [
            { name: 'Capybara', cost: 0, color: '#FFFFFF', unlocked: true, isImage: true, imageUrl: 'capybara.png' },
            { name: 'Poop', cost: 100, color: '#8B4513', unlocked: false, isImage: true, imageUrl: 'poop.png' },
            { name: 'SúperDX123', cost: 200, color: '#FFA500', unlocked: false, isImage: true, imageUrl: 'esteban.png' },
            { name: 'lushli', cost: 300, color: '#000000', unlocked: false, isImage: true, imageUrl: 'kily.png' },
            { name: 'Dragon', cost: 400, color: '#8A2BE2', unlocked: false, isImage: true, imageUrl: 'eyc.png' }
        ];
        let currentCharacter = characters[0]; // Initial character
        // Load unlocked characters from localStorage
        const savedCharacters = localStorage.getItem('characters') ? JSON.parse(localStorage.getItem('characters')) : ['Capybara'];
        characters.forEach(char => {
            // Update saved character names if they were the old ones
            if (char.name === 'SúperDX123' && savedCharacters.includes('Lion')) {
                char.unlocked = true;
            } else if (char.name === 'lushli' && savedCharacters.includes('Penguin')) {
                char.unlocked = true;
            } else if (savedCharacters.includes(char.name)) {
                char.unlocked = true;
            }
        });

        // --- Audio Configuration (Web Audio API) ---
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let audioBuffer = null; // Buffer for background music (TNT.mp3)
        let audioSource = null; // Current audio source for background music
        let audioStartTime = 0; // Time when music started
        let deathSoundBuffer = null; // Buffer for death sound
        let audioTimeoutId = null; // To store the setTimeout ID for stopping music

        // Asset paths
        const audioUrl = 'TNT.mp3';
        const deathSoundUrl = 'https://www.myinstants.com/media/sounds/8bit_explosion.mp3';
        const capybaraImageUrl = 'capybara.png';
        const poopImageUrl = 'poop.png';
        const cheeseImageUrl = 'cheese.png';
        const eycImageUrl = 'eyc.png';
        const estebanImageUrl = 'esteban.png';
        const kilyImageUrl = 'kily.png';
        const woolImageUrl = 'wool.png';
        const fenceImageUrl = 'fence.png';
        const lowFenceImageUrl = 'lowfence.webp'; // Added low fence image URL
        const spikeImageUrl = 'spike.png';
        const bladeImageUrl = 'blade.png';


        // Image buffers
        let capybaraImage = null;
        let poopImage = null;
        let cheeseImage = null;
        let eycImage = null;
        let estebanImage = null;
        let kilyImage = null;
        let woolImage = null;
        let fenceImage = null;
        let lowFenceImage = null; // Declared low fence image variable
        let spikeImage = null;
        let bladeImage = null;


        // --- Game Variables ---
        let particles = []; // Particles for visual effects
        let gameRunning = false;
        let isPaused = false;
        let currentLevel = 1;
        let practiceMode = false;
        let practiceStartTime = 0;
        let gameStartTime = 0;

        // Cloud variables
        let clouds = [];
        let lastCloudSpawnTime = 0;
        const cloudSpawnInterval = 3000;

        // Player object
        const player = {
            x: 100,
            y: 300,
            vy: 0,
            jumping: false,
            jumpHoldTime: 0,
            maxJumpHold: 500,
            width: 45, // Increased player width
            height: 45 // Increased player height
        };
        const gravity = 0.8;
        const jumpStrength = -12;
        let scrollPosition = 0;
        let scrollSpeed = 0;
        let objects = [];
        let terrain = [];

        // Global object ID counter
        let objectIdCounter = 0;

        // Helper function to create game objects with unique IDs
        function createGameObject(type, x, y, width, height, moving = null) {
            return { id: objectIdCounter++, type, position: { x, y }, width, height, moving };
        }

        // --- Asset Loading Functions ---

        /**
         * Loads an audio file using Web Audio API.
         * @param {string} url - The URL of the audio file.
         * @returns {Promise<AudioBuffer|null>} A promise that resolves with the AudioBuffer or null on failure.
         */
        async function loadAudio(url) {
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Audio fetch failed: ${response.status} for ${url}`);
                const arrayBuffer = await response.arrayBuffer();
                return await audioContext.decodeAudioData(arrayBuffer);
            } catch (error) {
                console.error('Error loading audio:', error);
                showError(`No se pudo cargar el audio: ${url}. Asegúrate de que la URL sea correcta y accesible.`);
                return null;
            }
        }

        /**
         * Loads an image.
         * @param {string} url - The URL of the image.
         * @returns {Promise<HTMLImageElement>} A promise that resolves with the loaded image.
         */
        function loadImage(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = () => {
                    console.warn(`Failed to load image: ${url}. Using placeholder.`);
                    // Fallback to a placeholder if the image fails to load
                    img.src = `https://placehold.co/${player.width}x${player.height}/cccccc/000000?text=Error`;
                    resolve(img); // Resolve even on error to continue game loading
                };
                img.src = url;
            });
        }

        /**
         * Loads all game assets (audio and images).
         */
        async function loadAssets() {
            console.log('Cargando assets...');
            try {
                // Load audio
                audioBuffer = await loadAudio(audioUrl);
                deathSoundBuffer = await loadAudio(deathSoundUrl);

                // Load images
                capybaraImage = await loadImage(capybaraImageUrl);
                poopImage = await loadImage(poopImageUrl);
                cheeseImage = await loadImage(cheeseImageUrl);
                eycImage = await loadImage(eycImageUrl);
                estebanImage = await loadImage(estebanImageUrl);
                kilyImage = await loadImage(kilyImageUrl);
                woolImage = await loadImage(woolImageUrl);
                fenceImage = await loadImage(fenceImageUrl);
                lowFenceImage = await loadImage(lowFenceImageUrl); // Load low fence image
                spikeImage = await loadImage(spikeImageUrl);
                bladeImage = await loadImage(bladeImageUrl);


                console.log('Assets cargados exitosamente');
            } catch (error) {
                console.error('Fallo al cargar assets:', error);
                showError('Error al cargar assets. Revisa la consola y asegúrate de que las URLs de los assets sean correctas y accesibles.');
            }
            menu.style.display = 'block'; // Show main menu once assets are loaded
        }

        /**
         * Displays a temporary error message on the screen.
         * @param {string} msg - The error message to display.
         */
        function showError(msg) {
            errorMessage.textContent = msg;
            errorMessage.style.display = 'block';
            setTimeout(() => errorMessage.style.display = 'none', 5000);
        }

        // --- Audio Control Functions ---

        /**
         * Plays a given AudioBuffer.
         * @param {AudioBuffer} buffer - The audio buffer to play.
         * @returns {AudioBufferSourceNode|null} The created audio source, or null if no buffer.
         */
        function playAudio(buffer) {
            if (buffer) {
                const source = audioContext.createBufferSource();
                source.buffer = buffer;
                source.connect(audioContext.destination);
                source.start(0);
                return source;
            }
            return null;
        }

        /**
         * Stops the current background music.
         */
        function stopAudio() {
            if (audioSource) {
                audioSource.stop();
                audioSource = null;
            }
            if (audioTimeoutId) {
                clearTimeout(audioTimeoutId);
                audioTimeoutId = null;
            }
        }

        // --- Particle Functions ---

        /**
         * Creates particles at a specific position with a given color.
         * @param {number} x - X coordinate.
         * @param {number} y - Y coordinate.
         * @param {number} count - Number of particles to create.
         * @param {string} color - Color of the particles (e.g., '#FFFFFF').
         */
        function createParticles(x, y, count, color) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x,
                    y,
                    vx: (Math.random() - 0.5) * 5,
                    vy: (Math.random() - 0.5) * 5,
                    size: 10,
                    alpha: 1,
                    color,
                    life: 0.5
                });
            }
        }

        // --- Cloud Functions ---

        /**
         * Creates a new cloud object.
         */
        function createCloud() {
            const size = 50 + Math.random() * 50;
            clouds.push({
                x: canvas.width,
                y: Math.random() * (canvas.height / 3),
                size: size,
                speed: 0.5 + Math.random() * 0.5,
                alpha: 0.8 + Math.random() * 0.2
            });
        }

        /**
         * Draws all clouds on the canvas.
         */
        function drawClouds() {
            clouds.forEach(cloud => {
                ctx.fillStyle = `rgba(255, 255, 255, ${cloud.alpha})`;
                ctx.beginPath();
                ctx.arc(cloud.x, cloud.y, cloud.size * 0.6, 0, Math.PI * 2);
                ctx.arc(cloud.x + cloud.size * 0.8, cloud.y, cloud.size * 0.5, 0, Math.PI * 2);
                ctx.arc(cloud.x + cloud.size * 0.4, cloud.y + cloud.size * 0.3, cloud.size * 0.7, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        /**
         * Updates cloud positions and manages their lifecycle.
         */
        function updateClouds(timestamp) {
            // Spawn new clouds
            if (timestamp - lastCloudSpawnTime > cloudSpawnInterval) {
                createCloud();
                lastCloudSpawnTime = timestamp;
            }

            // Move and filter clouds
            clouds = clouds.filter(cloud => {
                cloud.x -= cloud.speed;
                return cloud.x + cloud.size > 0;
            });
        }

        // --- Level Generation and Definition ---

        /**
         * Generates level objects based on a template.
         * This function now primarily adds the 'finish' object and ensures IDs are assigned.
         * @param {Array<Object>} baseObjects - Array of base objects (world coordinates).
         * @param {number} scrollSpeed - Level scroll speed.
         * @param {number} duration - Estimated level duration in seconds.
         * @returns {Array<Object>} Array of level objects with assigned IDs.
         */
        function generateLevelObjects(baseObjects, scrollSpeed, duration = 45) {
            // Deep copy base objects and assign IDs if not already present
            const objectsWithIds = baseObjects.map(obj => ({
                ...obj,
                id: obj.id !== undefined ? obj.id : objectIdCounter++,
                position: { ...obj.position }
            }));
            // Add 'finish' object at the end of the level
            const finishX = (duration * scrollSpeed * 60) + canvas.width;
            objectsWithIds.push(createGameObject('finish', finishX, 300, 40, 100));
            return objectsWithIds;
        }

        /**
         * Generates level terrain based on a template and repeats it to cover the duration.
         * @param {Array<Object>} baseTerrain - Array of base terrain segments.
         * @param {number} scrollSpeed - Level scroll speed.
         * @param {number} duration - Estimated level duration in seconds.
         * @returns {Array<Object>} Array of generated terrain segments.
         */
        function generateTerrain(baseTerrain, scrollSpeed, duration = 45) {
            // Calculate the width of one terrain cycle
            const cycleWidth = baseTerrain[baseTerrain.length - 1].x + baseTerrain[baseTerrain.length - 1].width;
            // Calculate the total width required for the level
            const requiredWidth = duration * scrollSpeed * 60;
            // Calculate how many terrain cycles are needed
            const cycles = Math.ceil(requiredWidth / cycleWidth) + 1;
            const terrain = [];
            for (let i = 0; i < cycles; i++) {
                baseTerrain.forEach(seg => {
                    terrain.push({ ...seg, x: seg.x + i * cycleWidth });
                });
            }
            return terrain;
        }

        const initialDelayX = 2.5 * 12 * 60; // 2.5 seconds * max scrollSpeed (12) * 60 frames/sec

        // Level definitions
        const levels = {
            1: {
                name: 'Facilito',
                scrollSpeed: 16.8, /* Reduced by 30% from 24 */
                practicePoints: [0, 10, 20, 30, 40],
                previewColor: '#00FF00',
                baseObjects: [
                    createGameObject('fence', initialDelayX + 300, 270, 80, 80), // Doubled size, adjusted Y
                    createGameObject('wool', initialDelayX + 450, 180, 60, 60), // Doubled size, appeared in sky
                    createGameObject('low_fence', initialDelayX + 600, 290, 40, 60), /* Adjusted size and Y */
                    createGameObject('spike', initialDelayX + 780, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 880, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('blade', initialDelayX + 1000, 180, 30, 30, { type: 'vertical', range: 40, speed: 1.5 }),
                    createGameObject('wool', initialDelayX + 1150, 120, 60, 60), // Doubled size
                    createGameObject('fence', initialDelayX + 1500, 270, 80, 80), // Doubled size, adjusted Y
                    createGameObject('spike', initialDelayX + 1650, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 1800, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('wool', initialDelayX + 1950, 180, 60, 60), // Doubled size, appeared in sky
                    createGameObject('low_fence', initialDelayX + 2100, 290, 40, 60), /* Adjusted size and Y */
                    createGameObject('blade', initialDelayX + 2250, 320, 30, 30, { type: 'horizontal', range: 50, speed: 2 }),
                    createGameObject('spring', initialDelayX + 2400, 330, 30, 20),
                    createGameObject('fence', initialDelayX + 2550, 270, 80, 80), // Doubled size, adjusted Y
                    createGameObject('spike', initialDelayX + 2700, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 2850, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('wool', initialDelayX + 3000, 180, 60, 60), // Doubled size, appeared in sky
                    createGameObject('low_fence', initialDelayX + 3150, 290, 40, 60), /* Adjusted size and Y */
                    createGameObject('blade', initialDelayX + 3300, 260, 30, 30, { type: 'vertical', range: 40, speed: 1.5 }),
                    createGameObject('spring', initialDelayX + 3450, 330, 30, 20),
                    createGameObject('fence', initialDelayX + 3600, 270, 80, 80), // Doubled size, adjusted Y
                    createGameObject('spike', initialDelayX + 3750, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 3900, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('wool', initialDelayX + 4050, 180, 60, 60), // Doubled size, appeared in sky
                    createGameObject('low_fence', initialDelayX + 4200, 290, 40, 60), /* Adjusted size and Y */
                    createGameObject('blade', initialDelayX + 4350, 320, 30, 30, { type: 'horizontal', range: 60, speed: 3 }),
                    createGameObject('spring', initialDelayX + 4500, 330, 30, 20),
                    createGameObject('fence', initialDelayX + 4650, 270, 80, 80), // Doubled size, adjusted Y
                    createGameObject('spike', initialDelayX + 4800, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 4950, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('wool', initialDelayX + 5100, 180, 60, 60), // Doubled size, appeared in sky
                    createGameObject('low_fence', initialDelayX + 5250, 290, 40, 60), /* Adjusted size and Y */
                    createGameObject('blade', initialDelayX + 5400, 260, 30, 30, { type: 'vertical', range: 50, speed: 2.5 }),
                    createGameObject('spring', initialDelayX + 5550, 330, 30, 20),
                    createGameObject('fence', initialDelayX + 5700, 270, 80, 80), // Doubled size, adjusted Y
                    createGameObject('spike', initialDelayX + 5850, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 6000, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('wool', initialDelayX + 6150, 180, 60, 60), // Doubled size, appeared in sky
                    createGameObject('low_fence', initialDelayX + 6300, 290, 40, 60), /* Adjusted size and Y */
                    createGameObject('blade', initialDelayX + 6450, 320, 30, 30, { type: 'horizontal', range: 70, speed: 3.5 }),
                    createGameObject('spring', initialDelayX + 6600, 330, 30, 20),
                    createGameObject('fence', initialDelayX + 6750, 270, 80, 80), // Doubled size, adjusted Y
                    createGameObject('spike', initialDelayX + 6900, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 7050, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('wool', initialDelayX + 7200, 180, 60, 60), // Doubled size, appeared in sky
                    createGameObject('low_fence', initialDelayX + 7350, 290, 40, 60), /* Adjusted size and Y */
                    createGameObject('blade', initialDelayX + 7500, 260, 30, 30, { type: 'vertical', range: 60, speed: 3 }),
                    createGameObject('spring', initialDelayX + 7650, 330, 30, 20),
                    createGameObject('fence', initialDelayX + 7800, 270, 80, 80), // Doubled size, adjusted Y
                    createGameObject('spike', initialDelayX + 7950, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 8100, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('wool', initialDelayX + 8250, 180, 60, 60), // Doubled size, appeared in sky
                    createGameObject('low_fence', initialDelayX + 8400, 290, 40, 60), /* Adjusted size and Y */
                    createGameObject('blade', initialDelayX + 8550, 320, 30, 30, { type: 'horizontal', range: 80, speed: 4 }),
                    createGameObject('spring', initialDelayX + 8700, 330, 30, 20),
                    createGameObject('fence', initialDelayX + 8850, 270, 80, 80), // Doubled size, adjusted Y
                    createGameObject('spike', initialDelayX + 9000, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 9150, 260, 90, 90) // 3x bigger, adjusted Y
                ],
                baseTerrain: [
                    { x: 0, y: 350, width: initialDelayX + 200, height: 50 }, // Starting platform
                    { x: initialDelayX + 250, y: 320, width: 100, height: 50 },
                    { x: initialDelayX + 400, y: 290, width: 100, height: 50 },
                    { x: initialDelayX + 550, y: 350, width: 200, height: 50 },
                    { x: initialDelayX + 700, y: 300, width: 80, height: 50 },
                    { x: initialDelayX + 830, y: 250, width: 80, height: 50 },
                    { x: initialDelayX + 960, y: 200, width: 80, height: 50 },
                    { x: initialDelayX + 1090, y: 150, width: 80, height: 50 },
                    { x: initialDelayX + 1300, y: 290, width: 100, height: 50 },
                    { x: initialDelayX + 1450, y: 350, width: 200, height: 50 },
                    { x: initialDelayX + 1700, y: 320, width: 150, height: 50 },
                    { x: initialDelayX + 1900, y: 290, width: 100, height: 50 },
                    { x: initialDelayX + 2100, y: 350, width: 200, height: 50 },
                    { x: initialDelayX + 2450, y: 290, width: 100, height: 50 },
                    { x: initialDelayX + 2600, y: 350, width: 300, height: 50 },
                    { x: initialDelayX + 2950, y: 320, width: 200, height: 50 },
                    { x: initialDelayX + 3200, y: 290, width: 150, height: 50 },
                    { x: initialDelayX + 3400, y: 350, width: 400, height: 50 },
                    { x: initialDelayX + 3850, y: 320, width: 250, height: 50 },
                    { x: initialDelayX + 4150, y: 290, width: 200, height: 50 },
                    { x: initialDelayX + 4400, y: 350, width: 500, height: 50 },
                    { x: initialDelayX + 4950, y: 320, width: 300, height: 50 },
                    { x: initialDelayX + 5300, y: 290, width: 250, height: 50 },
                    { x: initialDelayX + 5600, y: 350, width: 600, height: 50 },
                    { x: initialDelayX + 6250, y: 320, width: 350, height: 50 },
                    { x: initialDelayX + 6650, y: 290, width: 300, height: 50 },
                    { x: initialDelayX + 7000, y: 350, width: 700, height: 50 },
                    { x: initialDelayX + 7750, y: 320, width: 400, height: 50 },
                    { x: initialDelayX + 8200, y: 290, width: 350, height: 50 },
                    { x: initialDelayX + 8600, y: 350, width: 800, height: 50 },
                    { x: initialDelayX + 9450, y: 320, width: 500, height: 50 },
                    { x: initialDelayX + 10000, y: 290, width: 450, height: 50 }
                ]
            },
            2: {
                name: 'Ataque de Queso',
                scrollSpeed: 21, /* Reduced by 30% from 30 */
                practicePoints: [0, 10, 20, 30, 40],
                previewColor: '#FFD700',
                baseObjects: [
                    createGameObject('cheese', initialDelayX + 700, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 750, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 800, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 850, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 900, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 950, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 1000, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 1050, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 1100, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 1150, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 1200, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 1250, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 1300, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 1350, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 1400, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 1450, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 1500, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 1550, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 1600, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 1650, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 1700, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 1750, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 1800, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 1850, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 1900, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 1950, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 2000, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 2050, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 2100, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 2150, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 2200, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 2250, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 2300, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 2350, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 2400, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 2450, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 2500, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 2550, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 2600, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 2650, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 2700, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 2750, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 2800, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 2850, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 2900, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 2950, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 3000, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 3050, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 3100, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 3150, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 3200, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 3250, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 3300, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 3350, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 3400, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 3450, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 3500, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 3550, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 3600, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 3650, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 3700, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 3750, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 3800, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 3850, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 3900, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 3950, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 4000, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 4050, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 4100, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 4150, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 4200, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 4250, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 4300, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 4350, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 4400, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 4450, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 4500, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 4550, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 4600, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 4650, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 4700, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 4750, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 4800, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 4850, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 4900, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 4950, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 5000, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 5050, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 5100, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 5150, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 5200, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 5250, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 5300, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 5350, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 5400, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 5450, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 5500, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 5550, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 5600, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 5650, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 5700, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 5750, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 5800, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 5850, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 5900, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 5950, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 6000, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 6050, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 6100, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 6150, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 6200, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 6250, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 6300, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 6350, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 6400, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 6450, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 6500, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 6550, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 6600, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 6650, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 6700, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 6750, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 6800, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 6850, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 6900, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 6950, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 7000, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 7050, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 7100, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 7150, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 7200, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 7250, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 7300, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 7350, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 7400, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 7450, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 7500, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 7550, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 7600, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 7650, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 7700, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 7750, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 7800, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 7850, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 7900, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('cheese', initialDelayX + 7950, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('fence', initialDelayX + 1500, 270, 80, 80), // Doubled size, adjusted Y
                    createGameObject('low_fence', initialDelayX + 2100, 290, 40, 60), /* Adjusted size and Y */
                    createGameObject('spike', initialDelayX + 2700, 330, 30, 20),
                    createGameObject('blade', initialDelayX + 3300, 320, 30, 30, { type: 'horizontal', range: 100, speed: 5 }),
                    createGameObject('wool', initialDelayX + 3900, 180, 60, 60), // Doubled size, appeared in sky
                    createGameObject('giant_cheese', initialDelayX + 4500, 0, 90, 90), // Giant cheese at mid-level, starts at y=0 to fall
                    createGameObject('fence', initialDelayX + 4500, 270, 80, 80), // Doubled size, adjusted Y
                    createGameObject('low_fence', initialDelayX + 5100, 290, 40, 60), /* Adjusted size and Y */
                    createGameObject('spike', initialDelayX + 5700, 330, 30, 20),
                    createGameObject('blade', initialDelayX + 6300, 260, 30, 30, { type: 'vertical', range: 60, speed: 3 }),
                    createGameObject('wool', initialDelayX + 6900, 180, 60, 60), // Doubled size, appeared in sky
                    createGameObject('fence', initialDelayX + 7500, 270, 80, 80), // Doubled size, adjusted Y
                    createGameObject('low_fence', initialDelayX + 8100, 290, 40, 60), /* Adjusted size and Y */
                    createGameObject('spike', initialDelayX + 8700, 330, 30, 20),
                    createGameObject('blade', initialDelayX + 9300, 320, 30, 30, { type: 'horizontal', range: 100, speed: 5 })
                ],
                baseTerrain: [
                    { x: 0, y: 350, width: initialDelayX + 300, height: 50 }, // Starting platform
                    { x: initialDelayX + 400, y: 300, width: 200, height: 50 },
                    { x: initialDelayX + 700, y: 350, width: 200, height: 50 },
                    { x: initialDelayX + 1000, y: 310, width: 150, height: 40 },
                    { x: initialDelayX + 1200, y: 350, width: 500, height: 50 },
                    { x: initialDelayX + 1800, y: 300, width: 200, height: 50 },
                    { x: initialDelayX + 2100, y: 350, width: 600, height: 50 },
                    { x: initialDelayX + 2800, y: 320, width: 200, height: 50 },
                    { x: initialDelayX + 3100, y: 350, width: 800, height: 50 },
                    { x: initialDelayX + 4000, y: 300, width: 300, height: 50 },
                    { x: initialDelayX + 4400, y: 350, width: 2000, height: 50 },
                    { x: initialDelayX + 6500, y: 280, width: 400, height: 50 },
                    { x: initialDelayX + 7000, y: 350, width: 1000, height: 50 },
                    { x: initialDelayX + 8200, y: 310, width: 500, height: 50 },
                    { x: initialDelayX + 8800, y: 350, width: 1500, height: 50 }
                ]
            },
            3: {
                name: 'Imposible',
                scrollSpeed: 25.2, /* Reduced by 30% from 36 */
                practicePoints: [0, 10, 20, 30, 40],
                previewColor: '#FF0000',
                baseObjects: [
                    createGameObject('low_fence', initialDelayX + 800, 290, 40, 60), /* Adjusted size and Y */
                    createGameObject('spike', initialDelayX + 1000, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 1100, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('fence', initialDelayX + 1250, 270, 80, 80), // Doubled size, adjusted Y
                    createGameObject('spring', initialDelayX + 1450, 330, 30, 20),
                    createGameObject('spike', initialDelayX + 1550, 330, 30, 20),
                    createGameObject('wool', initialDelayX + 1700, 180, 60, 60), // Doubled size, appeared in sky
                    createGameObject('blade', initialDelayX + 1900, 260, 30, 30, { type: 'vertical', range: 80, speed: 4 }),
                    createGameObject('cheese', initialDelayX + 2000, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('low_fence', initialDelayX + 2150, 290, 40, 60), /* Adjusted size and Y */
                    createGameObject('spike', initialDelayX + 2350, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 2450, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('fence', initialDelayX + 2600, 270, 80, 80), // Doubled size, adjusted Y
                    createGameObject('spring', initialDelayX + 2800, 330, 30, 20),
                    createGameObject('spike', initialDelayX + 2900, 330, 30, 20),
                    createGameObject('wool', initialDelayX + 3050, 180, 60, 60), // Doubled size, appeared in sky
                    createGameObject('blade', initialDelayX + 3250, 320, 30, 30, { type: 'horizontal', range: 100, speed: 6 }),
                    createGameObject('cheese', initialDelayX + 3350, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('low_fence', initialDelayX + 3500, 290, 40, 60), /* Adjusted size and Y */
                    createGameObject('spike', initialDelayX + 3700, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 3800, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('fence', initialDelayX + 3950, 270, 80, 80), // Doubled size, adjusted Y
                    createGameObject('spring', initialDelayX + 4150, 330, 30, 20),
                    createGameObject('spike', initialDelayX + 4250, 330, 30, 20),
                    createGameObject('wool', initialDelayX + 4400, 180, 60, 60), // Doubled size, appeared in sky
                    createGameObject('blade', initialDelayX + 4600, 260, 30, 30, { type: 'vertical', range: 90, speed: 5 }),
                    createGameObject('cheese', initialDelayX + 4700, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('low_fence', initialDelayX + 4850, 290, 40, 60), /* Adjusted size and Y */
                    createGameObject('spike', initialDelayX + 5050, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 5150, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('fence', initialDelayX + 5300, 270, 80, 80), // Doubled size, adjusted Y
                    createGameObject('spring', initialDelayX + 5500, 330, 30, 20),
                    createGameObject('spike', initialDelayX + 5600, 330, 30, 20),
                    createGameObject('wool', initialDelayX + 5750, 180, 60, 60), // Doubled size, appeared in sky
                    createGameObject('blade', initialDelayX + 5950, 320, 30, 30, { type: 'horizontal', range: 120, speed: 7 }),
                    createGameObject('cheese', initialDelayX + 6050, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('low_fence', initialDelayX + 6200, 290, 40, 60), /* Adjusted size and Y */
                    createGameObject('spike', initialDelayX + 6400, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 6500, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('fence', initialDelayX + 6650, 270, 80, 80), // Doubled size, adjusted Y
                    createGameObject('spring', initialDelayX + 6850, 330, 30, 20),
                    createGameObject('spike', initialDelayX + 6950, 330, 30, 20),
                    createGameObject('wool', initialDelayX + 7100, 180, 60, 60), // Doubled size, appeared in sky
                    createGameObject('blade', initialDelayX + 7300, 260, 30, 30, { type: 'vertical', range: 100, speed: 6 }),
                    createGameObject('cheese', initialDelayX + 7400, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('low_fence', initialDelayX + 7550, 290, 40, 60), /* Adjusted size and Y */
                    createGameObject('spike', initialDelayX + 7750, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 7850, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('fence', initialDelayX + 8000, 270, 80, 80), // Doubled size, adjusted Y
                    createGameObject('spring', initialDelayX + 8200, 330, 30, 20),
                    createGameObject('spike', initialDelayX + 8300, 330, 30, 20),
                    createGameObject('wool', initialDelayX + 8450, 180, 60, 60), // Doubled size, appeared in sky
                    createGameObject('blade', initialDelayX + 8650, 320, 30, 30, { type: 'horizontal', range: 140, speed: 8 }),
                    createGameObject('cheese', initialDelayX + 8750, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('low_fence', initialDelayX + 8900, 290, 40, 60), /* Adjusted size and Y */
                    createGameObject('spike', initialDelayX + 9100, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 9200, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('fence', initialDelayX + 9350, 270, 80, 80), // Doubled size, adjusted Y
                    createGameObject('spring', initialDelayX + 9550, 330, 30, 20),
                    createGameObject('spike', initialDelayX + 9650, 330, 30, 20),
                    createGameObject('wool', initialDelayX + 9800, 180, 60, 60), // Doubled size, appeared in sky
                    createGameObject('blade', initialDelayX + 10000, 260, 30, 30, { type: 'vertical', range: 110, speed: 7 }),
                    createGameObject('cheese', initialDelayX + 10100, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('low_fence', initialDelayX + 10250, 290, 40, 60), /* Adjusted size and Y */
                    createGameObject('spike', initialDelayX + 10450, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 10550, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('fence', initialDelayX + 10700, 270, 80, 80), // Doubled size, adjusted Y
                    createGameObject('spring', initialDelayX + 10900, 330, 30, 20),
                    createGameObject('spike', initialDelayX + 11000, 330, 30, 20),
                    createGameObject('wool', initialDelayX + 11150, 180, 60, 60), // Doubled size, appeared in sky
                    createGameObject('blade', initialDelayX + 11350, 320, 30, 30, { type: 'horizontal', range: 160, speed: 9 }),
                    createGameObject('cheese', initialDelayX + 11450, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('low_fence', initialDelayX + 11600, 290, 40, 60), /* Adjusted size and Y */
                    createGameObject('spike', initialDelayX + 11800, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 11900, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('fence', initialDelayX + 12050, 270, 80, 80), // Doubled size, adjusted Y
                    createGameObject('spring', initialDelayX + 12250, 330, 30, 20),
                    createGameObject('spike', initialDelayX + 12350, 330, 30, 20),
                    createGameObject('wool', initialDelayX + 12500, 180, 60, 60), // Doubled size, appeared in sky
                    createGameObject('blade', initialDelayX + 12700, 260, 30, 30, { type: 'vertical', range: 120, speed: 8 }),
                    createGameObject('cheese', initialDelayX + 12800, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('low_fence', initialDelayX + 12950, 290, 40, 60), /* Adjusted size and Y */
                    createGameObject('spike', initialDelayX + 13150, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 13250, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('fence', initialDelayX + 13400, 270, 80, 80), // Doubled size, adjusted Y
                    createGameObject('spring', initialDelayX + 13600, 330, 30, 20),
                    createGameObject('spike', initialDelayX + 13700, 330, 30, 20),
                    createGameObject('wool', initialDelayX + 13850, 180, 60, 60), // Doubled size, appeared in sky
                    createGameObject('blade', initialDelayX + 14050, 320, 30, 30, { type: 'horizontal', range: 180, speed: 10 }),
                    createGameObject('cheese', initialDelayX + 14150, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('low_fence', initialDelayX + 14300, 290, 40, 60), /* Adjusted size and Y */
                    createGameObject('spike', initialDelayX + 14500, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 14600, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('fence', initialDelayX + 14750, 270, 80, 80), // Doubled size, adjusted Y
                    createGameObject('spring', initialDelayX + 14950, 330, 30, 20),
                    createGameObject('spike', initialDelayX + 15050, 330, 30, 20),
                    createGameObject('wool', initialDelayX + 15200, 180, 60, 60), // Doubled size, appeared in sky
                    createGameObject('blade', initialDelayX + 15400, 260, 30, 30, { type: 'vertical', range: 130, speed: 9 }),
                    createGameObject('cheese', initialDelayX + 15500, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('low_fence', initialDelayX + 15650, 290, 40, 60), /* Adjusted size and Y */
                    createGameObject('spike', initialDelayX + 15850, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 15950, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('fence', initialDelayX + 16100, 270, 80, 80), // Doubled size, adjusted Y
                    createGameObject('spring', initialDelayX + 16300, 330, 30, 20),
                    createGameObject('spike', initialDelayX + 16400, 330, 30, 20),
                    createGameObject('wool', initialDelayX + 16550, 180, 60, 60), // Doubled size, appeared in sky
                    createGameObject('blade', initialDelayX + 16750, 320, 30, 30, { type: 'horizontal', range: 200, speed: 11 }),
                    createGameObject('cheese', initialDelayX + 16850, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('low_fence', initialDelayX + 17000, 290, 40, 60), /* Adjusted size and Y */
                    createGameObject('spike', initialDelayX + 17200, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 17300, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('fence', initialDelayX + 17450, 270, 80, 80), // Doubled size, adjusted Y
                    createGameObject('spring', initialDelayX + 17650, 330, 30, 20),
                    createGameObject('spike', initialDelayX + 17750, 330, 30, 20),
                    createGameObject('wool', initialDelayX + 17900, 180, 60, 60), // Doubled size, appeared in sky
                    createGameObject('blade', initialDelayX + 18100, 260, 30, 30, { type: 'vertical', range: 140, speed: 10 }),
                    createGameObject('cheese', initialDelayX + 18200, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('low_fence', initialDelayX + 18350, 290, 40, 60), /* Adjusted size and Y */
                    createGameObject('spike', initialDelayX + 18550, 330, 30, 20),
                    createGameObject('cheese', initialDelayX + 18650, 260, 90, 90), // 3x bigger, adjusted Y
                    createGameObject('fence', initialDelayX + 18800, 270, 80, 80), // Doubled size, adjusted Y
                    createGameObject('spring', initialDelayX + 19000, 330, 30, 20),
                    createGameObject('spike', initialDelayX + 19100, 330, 30, 20)
                ],
                baseTerrain: [
                    { x: 0, y: 350, width: initialDelayX + 300, height: 50 }, // Starting platform
                    { x: initialDelayX + 400, y: 300, width: 200, height: 50 },
                    { x: initialDelayX + 700, y: 350, width: 200, height: 50 },
                    { x: initialDelayX + 1000, y: 310, width: 150, height: 40 },
                    { x: initialDelayX + 1200, y: 350, width: 500, height: 50 },
                    { x: initialDelayX + 1800, y: 300, width: 200, height: 50 },
                    { x: initialDelayX + 2100, y: 350, width: 600, height: 50 },
                    { x: initialDelayX + 2800, y: 320, width: 200, height: 50 },
                    { x: initialDelayX + 3100, y: 350, width: 800, height: 50 },
                    { x: initialDelayX + 4000, y: 300, width: 300, height: 50 },
                    { x: initialDelayX + 4400, y: 350, width: 2000, height: 50 },
                    { x: initialDelayX + 6500, y: 280, width: 400, height: 50 },
                    { x: initialDelayX + 7000, y: 350, width: 1000, height: 50 },
                    { x: initialDelayX + 8200, y: 310, width: 500, height: 50 },
                    { x: initialDelayX + 8800, y: 350, width: 1500, height: 50 },
                    // Ceiling for Level 3
                    { x: initialDelayX + 1000, y: 0, width: 2000, height: 50 } // Ceiling segment
                ]
            }
        };

        // Generates objects and terrain for each level at startup
        for (let levelId in levels) {
            levels[levelId].objects = generateLevelObjects(levels[levelId].baseObjects, levels[levelId].scrollSpeed, 45);
            levels[levelId].terrain = generateTerrain(levels[levelId].baseTerrain, levels[levelId].scrollSpeed, 45);
        }

        // --- Main Game Loop ---

        /**
         * Main game loop that runs every frame.
         * @param {DOMHighResTimeStamp} timestamp - The current time provided by requestAnimationFrame.
         */
        function gameLoop(timestamp) {
            if (!gameRunning || isPaused) return;
            update(timestamp);
            render();
            requestAnimationFrame(gameLoop);
        }

        /**
         * Updates the game state every frame.
         * @param {DOMHighResTimeStamp} timestamp - The current time.
         */
        function update(timestamp) {
            // Update player jump
            updateJump();
            // Apply gravity
            player.vy += gravity;
            player.y += player.vy;

            let onGround = false;
            let currentSegment = null;

            // Collision detection with terrain
            for (let segment of terrain) {
                const segX = segment.x - scrollPosition;

                // Check for collision with terrain segment
                if (player.x + player.width > segX && player.x < segX + segment.width) {
                    // Collision from bottom (landing on ground)
                    if (player.vy >= 0 && player.y + player.height > segment.y && player.y + player.height <= segment.y + player.vy + 10) {
                        player.y = segment.y - player.height;
                        player.vy = 0;
                        player.jumping = false;
                        player.jumpHoldTime = 0;
                        onGround = true;
                        break; // Player landed, no need to check other segments for landing
                    }
                    // Collision from top (hitting a ceiling)
                    if (player.vy < 0 && player.y < segment.y + segment.height && player.y + player.height > segment.y) {
                        handleDeath(); // Hit ceiling, player dies
                        return; // Exit update function as player died
                    }
                }
                // If player is not on the ground and falls below a terrain segment
                if (!onGround && currentSegment && player.y + player.height > currentSegment.y) {
                    let hasLowerSegment = false;
                    for (let segment of terrain) {
                        const segX = segment.x - scrollPosition;
                        if (player.x + player.width > segX && player.x < segX + segment.width &&
                            segment.y > currentSegment.y && player.y + player.height >= segment.y) {
                            hasLowerSegment = true;
                            break;
                        }
                    }
                    if (!hasLowerSegment) {
                        handleDeath();
                        return;
                    }
                }
            }

            // If player falls below the canvas (off-screen)
            if (!onGround && player.y > canvas.height) {
                handleDeath();
                return;
            }

            // Limit player from going off the top
            if (player.y < 0) {
                player.y = 0;
                player.vy = 0;
            }

            // Scroll the level
            scrollPosition += scrollSpeed;

            // Logic to add objects to the game based on their world position
            levels[currentLevel].objects.forEach(baseObj => {
                const alreadyActive = objects.some(activeObj => activeObj.id === baseObj.id);
                if (!alreadyActive) {
                    const screenX = baseObj.position.x - scrollPosition;
                    if (screenX <= canvas.width + 50 && baseObj.position.x > scrollPosition + player.x - 100) {
                        const newObj = { ...baseObj, currentY: baseObj.position.y };
                        if (newObj.type === 'cheese' || newObj.type === 'giant_cheese') { // Apply falling to giant cheese too
                            newObj.currentY = 0;
                            newObj.targetY = baseObj.position.y; // Use original Y as target
                            newObj.fallSpeed = 5;
                            newObj.falling = true;
                        } else {
                            newObj.currentY = newObj.position.y;
                        }
                        objects.push(newObj);
                    }
                }
            });
            // Filter out objects that have already passed the screen
            objects = objects.filter(obj => (obj.position.x - scrollPosition) > -obj.width);


            // Update position of moving and falling objects
            objects.forEach(obj => {
                if (obj.falling) {
                    obj.currentY += obj.fallSpeed;
                    if (obj.currentY >= obj.targetY) {
                        obj.currentY = obj.targetY;
                        obj.falling = false;
                    }
                }
                if (!obj.falling && obj.moving) {
                    if (obj.moving.type === 'vertical') {
                        obj.currentY += obj.moving.speed;
                        if (obj.currentY > obj.position.y || obj.currentY < obj.position.y - obj.moving.range) {
                            obj.moving.speed = -obj.moving.speed;
                        }
                    } else if (obj.moving.type === 'horizontal') {
                        if (obj.originalX === undefined) {
                            obj.originalX = obj.position.x;
                        }
                        obj.position.x += obj.moving.speed;
                        if (obj.position.x > obj.originalX + obj.moving.range || obj.position.x < obj.originalX) {
                            obj.moving.speed = -obj.moving.speed;
                        }
                    }
                }
            });

            // Update particle position and opacity
            particles = particles.filter(p => p.alpha > 0);
            particles.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.alpha -= 0.02;
                p.size *= 0.98;
            });

            // Update clouds
            updateClouds(timestamp);

            // Player collision detection with objects
            objects.forEach((obj, index) => {
                const objX = obj.position.x - scrollPosition;
                if (objX < -50 || objX > canvas.width) return;

                const objLeft = objX;
                const objRight = objX + obj.width;
                const objTop = obj.currentY || obj.position.y;
                const objBottom = objTop + obj.height;

                const playerLeft = player.x;
                const playerRight = player.x + player.width;
                const playerTop = player.y;
                const playerBottom = player.y + player.height;

                if (playerRight > objLeft && playerLeft < objRight && playerBottom > objTop && playerTop < objBottom) {
                    if (obj.type === 'wool') {
                        coins += 25;
                        localStorage.setItem('coins', coins);
                        coinDisplays.forEach(display => {
                            display.textContent = coins;
                            display.classList.add('highlight');
                            setTimeout(() => display.classList.remove('highlight'), 500);
                        });
                        createParticles(objX + obj.width / 2, objTop + obj.height / 2, 5, '#FFFFFF');
                        objects.splice(index, 1); // Remove wool when collected
                    } else if (obj.type === 'spring') {
                        player.vy = jumpStrength * 1.8;
                        player.jumping = true;
                        player.jumpHoldTime = 0;
                        createParticles(objX + obj.width / 2, objTop, 10, '#00FF00');
                        objects.splice(index, 1);
                    }
                    else if (obj.type === 'finish') {
                        gameRunning = false;
                        stopAudio();
                        const finalTime = (performance.now() - gameStartTime) / 1000;
                        document.getElementById('completionTime').textContent = `Tiempo: ${finalTime.toFixed(1)}s`;
                        levelComplete.style.display = 'block';
                        pauseButton.style.display = 'none';
                        objects = [];
                    } else { // Any other obstacle (fence, low_fence, spike, blade, cheese, giant_cheese)
                        handleDeath();
                    }
                }
            });
        }

        /**
         * Draws all game elements on the canvas.
         */
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const skyHeight = canvas.height * 0.6;
            const grassHeight = canvas.height * 0.4;
            
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, canvas.width, skyHeight);

            drawClouds();

            ctx.fillStyle = '#a8e4a0';
            ctx.fillRect(0, skyHeight, canvas.width, grassHeight);

            ctx.fillStyle = '#8B4513';
            terrain.forEach(segment => {
                const x = segment.x - scrollPosition;
                if (x + segment.width > 0 && x < canvas.width) {
                    ctx.fillRect(x, segment.y, segment.width, segment.height);
                }
            });

            // Draw objects (obstacles and collectibles)
            objects.forEach(obj => {
                const x = obj.position.x - scrollPosition;
                if (x < -50 || x > canvas.width) return;
                const y = obj.currentY || obj.position.y;

                switch (obj.type) {
                    case 'cheese':
                    case 'giant_cheese': // Draw giant cheese using the same image
                        if (cheeseImage) {
                            ctx.drawImage(cheeseImage, x, y, obj.width, obj.height);
                        } else {
                            ctx.fillStyle = '#FFD700';
                            ctx.fillRect(x, y, obj.width, obj.height);
                        }
                        break;
                    case 'fence':
                        if (fenceImage) {
                            ctx.drawImage(fenceImage, x, y, obj.width, obj.height);
                        } else {
                            ctx.fillStyle = '#FFD700';
                            ctx.fillRect(x, y, obj.width, obj.height);
                        }
                        break;
                    case 'low_fence':
                        if (lowFenceImage) { // Use the loaded low fence image
                            ctx.drawImage(lowFenceImage, x, y, obj.width, obj.height);
                        } else {
                            ctx.fillStyle = '#FFA500';
                            ctx.fillRect(x, y, obj.width, obj.height);
                        }
                        break;
                    case 'spike':
                        if (spikeImage) {
                            ctx.drawImage(spikeImage, x, y, obj.width, obj.height);
                        } else {
                            ctx.fillStyle = '#FF0000';
                            ctx.beginPath();
                            ctx.moveTo(x, y + obj.height);
                            ctx.lineTo(x + obj.width / 2, y);
                            ctx.lineTo(x + obj.width, y + obj.height);
                            ctx.fill();
                        }
                        break;
                    case 'blade':
                        if (bladeImage) {
                            ctx.drawImage(bladeImage, x, y, obj.width, obj.height);
                        } else {
                            ctx.fillStyle = '#000000';
                            ctx.beginPath();
                            ctx.arc(x + obj.width / 2, y + obj.height / 2, obj.width / 2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        break;
                    case 'wool':
                        if (woolImage) {
                            ctx.drawImage(woolImage, x, y, obj.width, obj.height);
                        } else {
                            ctx.fillStyle = '#FFFFFF';
                            ctx.beginPath();
                            ctx.arc(x + obj.width / 2, y + obj.height / 2, obj.width / 2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        break;
                    case 'spring':
                        ctx.fillStyle = '#00FF00';
                        ctx.fillRect(x, y, obj.width, obj.height);
                        ctx.fillStyle = '#000000';
                        ctx.font = '10px Arial';
                        ctx.fillText('↑', x + obj.width / 2 - 4, y + obj.height / 2 + 4);
                        break;
                    case 'finish':
                        ctx.fillStyle = '#00FF00';
                        ctx.fillRect(x, y, obj.width, obj.height);
                        break;
                }
            });

            // Draw particles
            particles.forEach(p => {
                ctx.fillStyle = `rgba(${parseInt(p.color.slice(1, 3), 16)}, ${parseInt(p.color.slice(3, 5), 16)}, ${parseInt(p.color.slice(5, 7), 16)}, ${p.alpha})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size / 2, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw player (using image or color based on selected character)
            if (currentCharacter.isImage && currentCharacter.imageUrl) {
                let charImage = null;
                switch (currentCharacter.name) {
                    case 'Capybara': charImage = capybaraImage; break;
                    case 'Poop': charImage = poopImage; break;
                    case 'SúperDX123': charImage = estebanImage; break;
                    case 'lushli': charImage = kilyImage; break;
                    case 'Dragon': charImage = eycImage; break;
                }
                if (charImage) {
                    ctx.drawImage(charImage, player.x, player.y, player.width, player.height);
                } else {
                    ctx.fillStyle = currentCharacter.color;
                    ctx.fillRect(player.x, player.y, player.width, player.height);
                }
            } else {
                ctx.fillStyle = currentCharacter.color;
                ctx.fillRect(player.x, player.y, player.width, player.height);
            }

            // Draw level text, time, and progress
            ctx.fillStyle = 'black';
            ctx.font = '16px Arial';
            const currentTime = gameRunning ? (performance.now() - gameStartTime) / 1000 : 0;
            const totalLevelWidth = levels[currentLevel].scrollSpeed * 60 * 45;
            const progressPercentage = Math.min(100, (scrollPosition / totalLevelWidth) * 100).toFixed(1);
            ctx.fillText(`Nivel: ${levels[currentLevel].name} | Tiempo: ${currentTime.toFixed(1)}s | Progreso: ${progressPercentage}%`, 10, 20);
        }

        // --- Player Control Functions ---

        /**
         * Handles player jump logic.
         */
        function updateJump() {
            if (player.jumping && player.jumpHoldTime < player.maxJumpHold) {
                player.vy = jumpStrength * (1 - player.jumpHoldTime / player.maxJumpHold);
                player.jumpHoldTime += 16;
            }
        }

        /**
         * Handles player death.
         */
        function handleDeath() {
            gameRunning = false;
            stopAudio();
            playAudio(deathSoundBuffer);
            showError('¡Has muerto! Inténtalo de nuevo.');
            returnToMenu();
            objects = [];
            particles = [];
        }

        // --- Menu and Game Control Functions ---

        /**
         * Starts the game with the specified level.
         * @param {number} levelId - The ID of the level to start.
         */
        function startGame(levelId) {
            if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    console.log('AudioContext reanudado');
                    startAudioAndGame(levelId);
                }).catch(e => {
                    console.error('Error al reanudar AudioContext:', e);
                    showError('No se pudo iniciar el audio. Por favor, interactúa con la página.');
                    startAudioAndGame(levelId);
                });
            } else {
                startAudioAndGame(levelId);
            }
        }

        /**
         * Helper function to start audio and game after AudioContext resumption.
         * @param {number} levelId - The ID of the level to start.
         */
        function startAudioAndGame(levelId) {
            stopAudio();
            if (audioBuffer) {
                audioSource = playAudio(audioBuffer);
                if (audioSource) {
                    const levelDurationSeconds = 45;
                    audioTimeoutId = setTimeout(() => {
                        stopAudio();
                    }, levelDurationSeconds * 1000);
                }
            }

            currentLevel = levelId;
            scrollPosition = 0;
            player.x = 100;
            player.y = 300;
            player.vy = 0;
            player.jumping = false;
            player.jumpHoldTime = 0;
            objects = [];
            terrain = levels[currentLevel].terrain;
            scrollSpeed = levels[currentLevel].scrollSpeed;
            clouds = [];
            lastCloudSpawnTime = 0;
            objectIdCounter = 0;

            menu.style.display = 'none';
            levelSelect.style.display = 'none';
            pauseMenu.style.display = 'none';
            characterMenu.style.display = 'none';
            levelComplete.style.display = 'none';
            pauseButton.style.display = 'flex';

            gameRunning = true;
            isPaused = false;
            gameStartTime = performance.now();
            requestAnimationFrame(gameLoop);
        }

        /**
         * Resumes the game from the pause menu.
         */
        function resumeGame() {
            isPaused = false;
            pauseMenu.style.display = 'none';
            pauseButton.style.display = 'flex';
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            requestAnimationFrame(gameLoop);
        }

        /**
         * Toggles the game pause state.
         */
        function togglePause() {
            isPaused = !isPaused;
            if (isPaused) {
                pauseMenu.style.display = 'block';
                pauseButton.style.display = 'none';
                if (audioContext.state === 'running') {
                    audioContext.suspend();
                }
            } else {
                resumeGame();
            }
        }

        /**
         * Shows the level selection menu.
         */
        function showLevelSelect() {
            menu.style.display = 'none';
            levelSelect.style.display = 'block';
            updateCoinDisplays();
            renderLevelList();
        }

        /**
         * Shows the character selection menu.
         */
        function showCharacters() {
            menu.style.display = 'none';
            pauseMenu.style.display = 'none';
            characterMenu.style.display = 'block';
            updateCoinDisplays();
            renderCharacterList();
        }

        /**
         * Returns to the main menu from any other menu.
         */
        function returnToMenu() {
            gameRunning = false;
            isPaused = false;
            stopAudio();
            menu.style.display = 'block';
            levelSelect.style.display = 'none';
            pauseMenu.style.display = 'none';
            characterMenu.style.display = 'none';
            levelComplete.style.display = 'none';
            pauseButton.style.display = 'none';
            updateCoinDisplays();
        }

        /**
         * Toggles practice mode.
         */
        function togglePractice() {
            practiceMode = !practiceMode;
            showError(`Modo Práctica: ${practiceMode ? 'Activado' : 'Desactivado'}`);
        }

        /**
         * Updates coin text in all displays.
         */
        function updateCoinDisplays() {
            coinDisplays.forEach(display => display.textContent = coins);
        }

        /**
         * Renders the list of levels in the level selection menu.
         */
        function renderLevelList() {
            const levelListDiv = document.getElementById('levelList');
            levelListDiv.innerHTML = '';
            for (let id in levels) {
                const level = levels[id];
                const levelDiv = document.createElement('div');
                levelDiv.className = 'level-preview';
                levelDiv.style.backgroundColor = level.previewColor;
                levelDiv.textContent = level.name;
                levelDiv.onclick = () => startGame(parseInt(id));
                levelListDiv.appendChild(levelDiv);
            }
        }

        /**
         * Renders the list of characters in the character selection menu.
         */
        function renderCharacterList() {
            const characterListDiv = document.getElementById('characterList');
            characterListDiv.innerHTML = '';

            characters.forEach(char => {
                const charOption = document.createElement('div');
                charOption.className = 'character-option';
                if (char.name === currentCharacter.name) {
                    charOption.classList.add('selected');
                }

                if (char.isImage && char.imageUrl) {
                    const img = document.createElement('img');
                    img.src = char.imageUrl;
                    img.alt = char.name;
                    charOption.appendChild(img);
                } else {
                    const colorBox = document.createElement('div');
                    colorBox.className = 'character-color-box';
                    colorBox.style.backgroundColor = char.color;
                    charOption.appendChild(colorBox);
                }

                const nameP = document.createElement('p');
                nameP.textContent = char.name;
                charOption.appendChild(nameP);

                if (char.unlocked) {
                    const selectButton = document.createElement('button');
                    selectButton.textContent = 'Seleccionar';
                    selectButton.onclick = () => {
                        currentCharacter = char;
                        renderCharacterList();
                    };
                    selectButton.disabled = (char.name === currentCharacter.name);
                    charOption.appendChild(selectButton);
                } else {
                    const costP = document.createElement('p');
                    costP.className = 'cost';
                    costP.textContent = `Costo: ${char.cost} Monedas`;
                    charOption.appendChild(costP);

                    const buyButton = document.createElement('button');
                    buyButton.textContent = 'Comprar';
                    buyButton.disabled = (coins < char.cost);
                    buyButton.onclick = () => {
                        if (coins >= char.cost) {
                            coins -= char.cost;
                            char.unlocked = true;
                            localStorage.setItem('coins', coins);
                            const currentSavedChars = localStorage.getItem('characters') ? JSON.parse(localStorage.getItem('characters')) : [];
                            currentSavedChars.push(char.name);
                            localStorage.setItem('characters', JSON.stringify(currentSavedChars));
                            updateCoinDisplays();
                            renderCharacterList();
                            showError(`¡${char.name} desbloqueado!`);
                        } else {
                            showError('¡No tienes suficientes monedas!');
                        }
                    };
                    charOption.appendChild(buyButton);
                }
                characterListDiv.appendChild(charOption);
            });
        }

        // --- Event Listeners ---

        // Handle jump with spacebar
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && gameRunning && !isPaused && !player.jumping) {
                player.jumping = true;
                player.jumpHoldTime = 0;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space' && gameRunning && !isPaused && player.jumping) {
                player.jumping = false;
            }
        });

        // Handle jump with mouse click on canvas
        canvas.addEventListener('mousedown', (e) => {
            if (gameRunning && !isPaused && !player.jumping) {
                player.jumping = true;
                player.jumpHoldTime = 0;
            }
        });

        // Event to start loading assets when window is fully loaded
        window.onload = function () {
            loadAssets();
        };

    </script>
</body>
</html>
