<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Capybara Dash - Task 5</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: #f0f0f0;
            font-family: Arial, sans-serif;
        }
        #gameCanvas {
            border: 1px solid #000;
            background: #a8e4a0;
        }
        #menu, #pauseMenu, #levelSelect, #characterMenu, #levelComplete {
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
        }
        button:hover {
            background: #45a049;
        }
        button:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }
        #coinDisplay, #coinDisplayPause, #coinDisplayLevel, #coinDisplayCharacter {
            font-weight: bold;
            transition: color 0.5s;
        }
        .highlight {
            color: #4CAF50;
        }
        #levelComplete h2 {
            font-size: 24px;
            color: #4CAF50;
        }
        #levelComplete p {
            font-size: 18px;
            color: #333;
        }
        .level-preview {
            width: 100px;
            height: 60px;
            margin: 10px;
            display: inline-block;
        }
        #pauseButton {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 30px;
            height: 30px;
            background: #FF0000;
            border-radius: 50%;
            cursor: pointer;
            display: none;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="400"></canvas>
    <div id="menu">
        <h2>Capybara Dash</h2>
        <button onclick="startGame(1)">Jugar</button>
        <button onclick="showLevelSelect()">Seleccionar Nivel</button>
        <button onclick="showCharacters()">Seleccionar Personaje</button>
        <button onclick="togglePractice()">Modo Práctica</button>
        <p>Monedas: <span id="coinDisplay">0</span></p>
    </div>
    <div id="levelSelect">
        <h2>Seleccionar Nivel</h2>
        <div id="levelList"></div>
        <button onclick="returnToMenu()">Volver</button>
        <p>Monedas: <span id="coinDisplayLevel">0</span></p>
    </div>
    <div id="pauseMenu">
        <h2>Pausado</h2>
        <button onclick="resumeGame()">Reanudar</button>
        <button onclick="togglePractice()">Modo Práctica</button>
        <button onclick="showCharacters()">Seleccionar Personaje</button>
        <button onclick="returnToMenu()">Menú Principal</button>
        <p>Monedas: <span id="coinDisplayPause">0</span></p>
    </div>
    <div id="characterMenu">
        <h2>Seleccionar Personaje</h2>
        <div id="characterList"></div>
        <button onclick="returnToMenu()">Volver</button>
        <p>Monedas: <span id="coinDisplayCharacter">0</span></p>
    </div>
    <div id="levelComplete">
        <h2>¡Buena, Oveja! Lo lograste!</h2>
        <p id="completionTime"></p>
        <button onclick="returnToMenu()">Menú Principal</button>
    </div>
    <div id="pauseButton"></div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const menu = document.getElementById('menu');
        const levelSelect = document.getElementById('levelSelect');
        const pauseMenu = document.getElementById('pauseMenu');
        const characterMenu = document.getElementById('characterMenu');
        const levelComplete = document.getElementById('levelComplete');
        const pauseButton = document.getElementById('pauseButton');
        let coins = localStorage.getItem('coins') ? parseInt(localStorage.getItem('coins')) : 0;
        const coinDisplays = [
            document.getElementById('coinDisplay'),
            document.getElementById('coinDisplayPause'),
            document.getElementById('coinDisplayLevel'),
            document.getElementById('coinDisplayCharacter')
        ];
        coinDisplays.forEach(display => display.textContent = coins);

        const characters = [
            { name: 'Sheep', cost: 0, color: '#FFFFFF', unlocked: true, isImage: true },
            { name: 'Poop', cost: 100, color: '#8B4513', unlocked: false },
            { name: 'Lion', cost: 200, color: '#FFA500', unlocked: false },
            { name: 'Penguin', cost: 300, color: '#000000', unlocked: false },
            { name: 'Hamburger', cost: 400, color: '#A52A2A', unlocked: false }
        ];
        let currentCharacter = characters[0];
        const savedCharacters = localStorage.getItem('characters') ? JSON.parse(localStorage.getItem('characters')) : ['Sheep'];
        characters.forEach(char => {
            if (savedCharacters.includes(char.name)) char.unlocked = true;
        });

        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let audioBuffer = null;
        let audioSource = null;
        let audioStartTime = 0;
        let deathSoundBuffer = null;
        let sheepImage = null;
        const audioUrl = './tnt.mp3';
        const deathSoundUrl = 'https://www.myinstants.com/media/sounds/8bit_explosion.mp3';
        const sheepImageUrl = './sheep.png';

        let particles = [];

        async function loadAudio(url) {
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Audio fetch failed: ${response.status}`);
                const arrayBuffer = await response.arrayBuffer();
                return await audioContext.decodeAudioData(arrayBuffer);
            } catch (error) {
                console.error('Error loading audio:', error);
                return null;
            }
        }

        function loadImage(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = () => reject(new Error(`Failed to load image: ${url}`));
                img.src = url;
            });
        }

        async function loadAssets() {
            try {
                audioBuffer = await loadAudio(audioUrl);
                deathSoundBuffer = await loadAudio(deathSoundUrl);
                sheepImage = await loadImage(sheepImageUrl);
                console.log('Assets loaded successfully');
            } catch (error) {
                console.error('Asset loading failed:', error);
                sheepImage = null;
            }
        }

        function playAudio(buffer) {
            if (buffer) {
                const source = audioContext.createBufferSource();
                source.buffer = buffer;
                source.connect(audioContext.destination);
                source.start();
                return source;
            }
            return null;
        }

        function stopAudio() {
            if (audioSource) {
                audioSource.stop();
                audioSource = null;
            }
        }

        function createParticles(x, y, count, color) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x,
                    y,
                    vx: (Math.random() - 0.5) * 5,
                    vy: (Math.random() - 0.5) * 5,
                    size: 10,
                    alpha: 1,
                    color,
                    life: 0.5
                });
            }
        }

        let gameRunning = false;
        let isPaused = false;
        let currentLevel = 1;
        let practiceMode = false;
        let practiceStartTime = 0;
        let gameStartTime = 0;
        const player = {
            x: 100,
            y: 300,
            vy: 0,
            jumping: false,
            jumpHoldTime: 0,
            maxJumpHold: 500,
            width: 30,
            height: 30
        };
        const gravity = 0.8;
        const jumpStrength = -12;
        let scrollPosition = 0;
        let scrollSpeed = 0;
        let objects = [];
        let terrain = [];

        function generateLevelObjects(baseObjects, scrollSpeed, duration = 90) {
            const objects = baseObjects.map(obj => ({
                ...obj,
                position: { ...obj.position }
            }));
            objects.push({ time: 89, type: 'finish', position: { x: 800 + 89 * scrollSpeed * 60, y: 300 }, width: 40, height: 100 });
            return objects;
        }

        function generateTerrain(baseTerrain, scrollSpeed, duration = 90) {
            const cycleWidth = baseTerrain[baseTerrain.length - 1].x + baseTerrain[baseTerrain.length - 1].width;
            const requiredWidth = duration * scrollSpeed * 60;
            const cycles = Math.ceil(requiredWidth / cycleWidth) + 1;
            const terrain = [];
            for (let i = 0; i < cycles; i++) {
                baseTerrain.forEach(seg => {
                    terrain.push({ ...seg, x: seg.x + i * cycleWidth });
                });
            }
            return terrain;
        }

        const levels = {
            1: {
                name: 'Facilito',
                scrollSpeed: 12,
                practicePoints: [0, 10, 20, 30, 60, 89],
                previewColor: '#00FF00',
                baseObjects: [
                    { time: 2.0, type: 'fence', position: { x: 800, y: 350 }, width: 40, height: 40 },
                    { time: 3.5, type: 'cheese', position: { x: 1200, y: 350 }, width: 30, height: 30 },
                    { time: 5.0, type: 'wool', position: { x: 1600, y: 280 }, width: 30, height: 30 },
                    { time: 6.5, type: 'spike', position: { x: 2000, y: 320 }, width: 30, height: 20 },
                    { time: 8.0, type: 'fence', position: { x: 2400, y: 350 }, width: 40, height: 40 },
                    { time: 9.5, type: 'cheese', position: { x: 2800, y: 350 }, width: 30, height: 30 },
                    { time: 11.0, type: 'bird', position: { x: 3200, y: 280 }, width: 30, height: 20, moving: { type: 'horizontal', range: 200, speed: 12 } },
                    { time: 13.0, type: 'wool', position: { x: 3600, y: 300 }, width: 30, height: 30 },
                    { time: 15.0, type: 'spike', position: { x: 4000, y: 350 }, width: 30, height: 20 },
                    { time: 17.0, type: 'fence', position: { x: 4400, y: 350 }, width: 40, height: 40 },
                    { time: 19.0, type: 'cheese', position: { x: 4800, y: 350 }, width: 30, height: 30 },
                    { time: 21.0, type: 'bird', position: { x: 5200, y: 280 }, width: 30, height: 20, moving: { type: 'horizontal', range: 200, speed: 12 } },
                    { time: 23.5, type: 'wool', position: { x: 5600, y: 280 }, width: 30, height: 30 },
                    { time: 26.0, type: 'spike', position: { x: 6000, y: 350 }, width: 30, height: 20 },
                    { time: 28.5, type: 'fence', position: { x: 6400, y: 350 }, width: 40, height: 40 },
                    { time: 31.0, type: 'cheese', position: { x: 6800, y: 350 }, width: 30, height: 30 },
                    { time: 33.5, type: 'wool', position: { x: 7200, y: 300 }, width: 30, height: 30 },
                    { time: 36.0, type: 'spike', position: { x: 7600, y: 350 }, width: 30, height: 20 },
                    { time: 38.5, type: 'fence', position: { x: 8000, y: 350 }, width: 40, height: 40 },
                    { time: 41.0, type: 'cheese', position: { x: 8400, y: 350 }, width: 30, height: 30 },
                    { time: 43.5, type: 'bird', position: { x: 8800, y: 280 }, width: 30, height: 20, moving: { type: 'horizontal', range: 200, speed: 12 } },
                    { time: 46.0, type: 'wool', position: { x: 9200, y: 280 }, width: 30, height: 30 },
                    { time: 48.5, type: 'spike', position: { x: 9600, y: 350 }, width: 30, height: 20 }
                ],
                baseTerrain: [
                    { x: 0, y: 350, width: 600, height: 50 },
                    { x: 700, y: 320, width: 200, height: 50 },
                    { x: 950, y: 350, width: 400, height: 50 },
                    { x: 1400, y: 300, width: 300, height: 50 },
                    { x: 1800, y: 350, width: 600, height: 50 },
                    { x: 2500, y: 320, width: 200, height: 50 },
                    { x: 2800, y: 350, width: 800, height: 50 },
                    { x: 3700, y: 300, width: 300, height: 50 },
                    { x: 4100, y: 350, width: 1000, height: 50 },
                    { x: 5200, y: 320, width: 200, height: 50 },
                    { x: 5500, y: 350, width: 2000, height: 50 }
                ]
            },
            2: {
                name: 'Ataque de queso',
                scrollSpeed: 12,
                practicePoints: [0, 10, 20, 30, 60, 89],
                previewColor: '#FFD700',
                baseObjects: [
                    { time: 2.0, type: 'cheese', position: { x: 800, y: 350 }, width: 30, height: 30 },
                    { time: 3.5, type: 'fence', position: { x: 1200, y: 350 }, width: 40, height: 40 },
                    { time: 5.0, type: 'wool', position: { x: 1600, y: 280 }, width: 30, height: 30 },
                    { time: 6.5, type: 'cheese', position: { x: 2000, y: 350 }, width: 30, height: 30 },
                    { time: 8.0, type: 'bird', position: { x: 2400, y: 280 }, width: 30, height: 20, moving: { type: 'horizontal', range: 200, speed: 12 } },
                    { time: 10.0, type: 'spike', position: { x: 2800, y: 350 }, width: 30, height: 20 },
                    { time: 12.0, type: 'cheese', position: { x: 3200, y: 350 }, width: 30, height: 30 },
                    { time: 14.0, type: 'wool', position: { x: 3600, y: 300 }, width: 30, height: 30 },
                    { time: 16.0, type: 'fence', position: { x: 4000, y: 350 }, width: 40, height: 40 },
                    { time: 18.0, type: 'cheese', position: { x: 4400, y: 350 }, width: 30, height: 30 },
                    { time: 20.0, type: 'bird', position: { x: 4800, y: 280 }, width: 30, height: 20, moving: { type: 'horizontal', range: 200, speed: 12 } },
                    { time: 22.5, type: 'spike', position: { x: 5200, y: 350 }, width: 30, height: 20 },
                    { time: 25.0, type: 'wool', position: { x: 5600, y: 280 }, width: 30, height: 30 },
                    { time: 27.5, type: 'cheese', position: { x: 6000, y: 350 }, width: 30, height: 30 },
                    { time: 30.0, type: 'fence', position: { x: 6400, y: 350 }, width: 40, height: 40 },
                    { time: 32.5, type: 'bird', position: { x: 6800, y: 280 }, width: 30, height: 20, moving: { type: 'horizontal', range: 200, speed: 12 } },
                    { time: 35.0, type: 'cheese', position: { x: 7200, y: 350 }, width: 30, height: 30 },
                    { time: 37.5, type: 'wool', position: { x: 7600, y: 300 }, width: 30, height: 30 },
                    { time: 40.0, type: 'spike', position: { x: 8000, y: 350 }, width: 30, height: 20 },
                    { time: 42.5, type: 'cheese', position: { x: 8400, y: 350 }, width: 30, height: 30 },
                    { time: 45.0, type: 'fence', position: { x: 8800, y: 350 }, width: 40, height: 40 },
                    { time: 47.5, type: 'wool', position: { x: 9200, y: 280 }, width: 30, height: 30 },
                    { time: 50.0, type: 'bird', position: { x: 9600, y: 280 }, width: 30, height: 20, moving: { type: 'horizontal', range: 200, speed: 12 } }
                ],
                baseTerrain: [
                    { x: 0, y: 350, width: 300, height: 50 },
                    { x: 400, y: 300, width: 200, height: 50 },
                    { x: 700, y: 350, width: 200, height: 50 },
                    { x: 1000, y: 310, width: 150, height: 40 },
                    { x: 1200, y: 350, width: 500, height: 50 },
                    { x: 1800, y: 300, width: 200, height: 50 },
                    { x: 2100, y: 350, width: 600, height: 50 },
                    { x: 2800, y: 320, width: 200, height: 50 },
                    { x: 3100, y: 350, width: 800, height: 50 },
                    { x: 4000, y: 300, width: 300, height: 50 },
                    { x: 4400, y: 350, width: 2000, height: 50 }
                ]
            },
            3: {
                name: 'Imposible',
                scrollSpeed: 12,
                practicePoints: [0, 10, 20, 30, 60, 89],
                previewColor: '#FF0000',
                baseObjects: [
                    { time: 2.0, type: 'spike', position: { x: 800, y: 350 }, width: 30, height: 20 },
                    { time: 3.5, type: 'cheese', position: { x: 1200, y: 350 }, width: 30, height: 30 },
                    { time: 5.0, type: 'blade', position: { x: 1600, y: 260 }, width: 30, height: 30, moving: { type: 'vertical', range: 50, speed: 2.5 } },
                    { time: 6.5, type: 'wool', position: { x: 2000, y: 280 }, width: 30, height: 30 },
                    { time: 8.0, type: 'fence', position: { x: 2400, y: 350 }, width: 40, height: 40 },
                    { time: 10.0, type: 'bird', position: { x: 2800, y: 280 }, width: 30, height: 20, moving: { type: 'horizontal', range: 200, speed: 12 } },
                    { time: 12.0, type: 'cheese', position: { x: 3200, y: 350 }, width: 30, height: 30 },
                    { time: 14.0, type: 'spike', position: { x: 3600, y: 350 }, width: 30, height: 20 },
                    { time: 16.0, type: 'wool', position: { x: 4000, y: 300 }, width: 30, height: 30 },
                    { time: 18.0, type: 'fence', position: { x: 4400, y: 350 }, width: 40, height: 40 },
                    { time: 20.0, type: 'cheese', position: { x: 4800, y: 350 }, width: 30, height: 30 },
                    { time: 22.5, type: 'bird', position: { x: 5200, y: 280 }, width: 30, height: 20, moving: { type: 'horizontal', range: 200, speed: 12 } },
                    { time: 25.0, type: 'spike', position: { x: 5600, y: 350 }, width: 30, height: 20 },
                    { time: 27.5, type: 'wool', position: { x: 6000, y: 280 }, width: 30, height: 30 },
                    { time: 30.0, type: 'blade', position: { x: 6400, y: 260 }, width: 30, height: 30, moving: { type: 'vertical', range: 50, speed: 2.5 } },
                    { time: 32.5, type: 'cheese', position: { x: 6800, y: 350 }, width: 30, height: 30 },
                    { time: 35.0, type: 'fence', position: { x: 7200, y: 350 }, width: 40, height: 40 },
                    { time: 37.5, type: 'bird', position: { x: 7600, y: 280 }, width: 30, height: 20, moving: { type: 'horizontal', range: 200, speed: 12 } },
                    { time: 40.0, type: 'spike', position: { x: 8000, y: 350 }, width: 30, height: 20 },
                    { time: 42.5, type: 'wool', position: { x: 8400, y: 300 }, width: 30, height: 30 },
                    { time: 45.0, type: 'cheese', position: { x: 8800, y: 350 }, width: 30, height: 30 },
                    { time: 47.5, type: 'fence', position: { x: 9200, y: 350 }, width: 40, height: 40 },
                    { time: 50.0, type: 'wool', position: { x: 9600, y: 280 }, width: 30, height: 30 }
                ],
                baseTerrain: [
                    { x: 0, y: 350, width: 200, height: 50 },
                    { x: 250, y: 300, width: 150, height: 50 },
                    { x: 450, y: 330, width: 100, height: 20 },
                    { x: 600, y: 280, width: 150, height: 50 },
                    { x: 800, y: 310, width: 100, height: 40 },
                    { x: 950, y: 350, width: 200, height: 50 },
                    { x: 1200, y: 300, width: 150, height: 50 },
                    { x: 1400, y: 350, width: 600, height: 50 },
                    { x: 2100, y: 320, width: 200, height: 50 },
                    { x: 2400, y: 350, width: 800, height: 50 },
                    { x: 3300, y: 300, width: 300, height: 50 },
                    { x: 3700, y: 350, width: 2000, height: 50 }
                ]
            }
        };

        for (let level in levels) {
            levels[level].objects = generateLevelObjects(levels[level].baseObjects, levels[level].scrollSpeed);
            levels[level].terrain = generateTerrain(levels[level].baseTerrain, levels[level].scrollSpeed);
        }

        function gameLoop(timestamp) {
            if (!gameRunning || isPaused) return;
            update(timestamp);
            render();
            requestAnimationFrame(gameLoop);
        }

        function update(timestamp) {
            updateJump();
            player.vy += gravity;
            player.y += player.vy;

            let onGround = false;
            let currentSegment = null;
            for (let segment of terrain) {
                const segX = segment.x - scrollPosition;
                if (player.x + player.width > segX && player.x < segX + segment.width &&
                    player.y + player.height > segment.y && player.y + player.height <= segment.y + player.vy + 10) {
                    player.y = segment.y - player.height;
                    player.vy = 0;
                    player.jumping = false;
                    player.jumpHoldTime = 0;
                    onGround = true;
                    break;
                }
                if (player.x + player.width > segX && player.x < segX + segment.width) {
                    currentSegment = segment;
                }
            }

            if (!onGround && currentSegment && player.y + player.height > currentSegment.y) {
                let hasLowerSegment = false;
                for (let segment of terrain) {
                    const segX = segment.x - scrollPosition;
                    if (player.x + player.width > segX && player.x < segX + segment.width &&
                        segment.y > currentSegment.y && player.y + player.height >= segment.y) {
                        hasLowerSegment = true;
                        break;
                    }
                }
                if (!hasLowerSegment) {
                    handleDeath();
                    return;
                }
            }

            if (!onGround && player.y > 350) {
                player.y = 350;
                player.vy = 0;
                player.jumping = false;
                player.jumpHoldTime = 0;
            }

            if (player.y < 0) {
                player.y = 0;
                player.vy = 0;
            }

            scrollPosition += scrollSpeed;

            const currentTime = audioBuffer ? audioContext.currentTime - audioStartTime + practiceStartTime : timestamp / 1000;
            objects = objects.filter(obj => obj.position.x - scrollPosition > -100);
            levels[currentLevel].objects.forEach(event => {
                if (currentTime >= event.time && !objects.includes(event)) {
                    const newObj = { ...event, position: { ...event.position } };
                    if (newObj.type === 'cheese') {
                        newObj.currentY = 0;
                        newObj.targetY = newObj.position.y;
                        newObj.fallSpeed = 5;
                        newObj.falling = true;
                    } else {
                        newObj.currentY = newObj.position.y;
                    }
                    if (newObj.type === 'cheese' && objects.filter(o => o.type === 'cheese' && o.falling).length >= 1) {
                        return;
                    }
                    objects.push(newObj);
                }
            });

            objects.forEach(obj => {
                if (obj.falling) {
                    obj.currentY += obj.fallSpeed;
                    if (obj.currentY >= obj.targetY) {
                        obj.currentY = obj.targetY;
                        obj.falling = false;
                    }
                }
                if (!obj.falling && obj.moving) {
                    if (obj.moving.type === 'vertical') {
                        obj.currentY += obj.moving.speed;
                        if (obj.currentY > obj.position.y || obj.currentY < obj.position.y - obj.moving.range) {
                            obj.moving.speed = -obj.moving.speed;
                        }
                    } else if (obj.moving.type === 'horizontal') {
                        obj.position.x += obj.moving.speed;
                        if (obj.position.x > obj.position.x + obj.moving.range || obj.position.x < obj.position.x) {
                            obj.moving.speed = -obj.moving.speed;
                        }
                    }
                }
            });

            particles = particles.filter(p => p.alpha > 0);
            particles.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.alpha -= 0.02;
                p.size *= 0.98;
            });

            objects.forEach((obj, index) => {
                const objX = obj.position.x - scrollPosition;
                if (objX < -100 || objX > canvas.width) return;
                const objLeft = objX;
                const objRight = objX + obj.width;
                const objTop = obj.currentY || obj.position.y;
                const objBottom = objTop + obj.height;
                const playerLeft = player.x;
                const playerRight = player.x + player.width;
                const playerTop = player.y;
                const playerBottom = player.y + player.height;

                if (playerRight > objLeft && playerLeft < objRight && playerBottom > objTop && playerTop < objBottom) {
                    if (obj.type === 'wool') {
                        coins += 1;
                        localStorage.setItem('coins', coins);
                        coinDisplays.forEach(display => {
                            display.textContent = coins;
                            display.classList.add('highlight');
                            setTimeout(() => display.classList.remove('highlight'), 500);
                        });
                        createParticles(objX + obj.width / 2, objTop + obj.height / 2, 5, '#FFFFFF');
                        objects.splice(index, 1);
                    } else if (obj.type === 'finish') {
                        gameRunning = false;
                        stopAudio();
                        const finalTime = (performance.now() - gameStartTime) / 1000;
                        document.getElementById('completionTime').textContent = `Tiempo: ${finalTime.toFixed(1)}s`;
                        levelComplete.style.display = 'block';
                        pauseButton.style.display = 'none';
                        objects = [];
                    } else {
                        handleDeath();
                    }
                }
            });
        }

        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            console.log('Rendering frame');

            ctx.fillStyle = '#8B4513';
            terrain.forEach(segment => {
                const x = segment.x - scrollPosition;
                if (x + segment.width > 0 && x < canvas.width) {
                    ctx.fillRect(x, segment.y, segment.width, segment.height);
                }
            });

            objects.forEach(obj => {
                const x = obj.position.x - scrollPosition;
                if (x < -100 || x > canvas.width) return;
                const y = obj.currentY || obj.position.y;
                switch (obj.type) {
                    case 'cheese':
                        ctx.fillStyle = '#FFD700';
                        ctx.fillRect(x, y, obj.width, obj.height);
                        break;
                    case 'fence':
                        ctx.fillStyle = '#8B5A2B';
                        ctx.fillRect(x, y, obj.width, obj.height);
                        break;
                    case 'spike':
                        ctx.fillStyle = '#FF0000';
                        ctx.beginPath();
                        ctx.moveTo(x, y + obj.height);
                        ctx.lineTo(x + obj.width / 2, y);
                        ctx.lineTo(x + obj.width, y + obj.height);
                        ctx.fill();
                        break;
                    case 'bird':
                        ctx.fillStyle = '#A52A2A';
                        ctx.fillRect(x, y, obj.width, obj.height);
                        break;
                    case 'blade':
                        ctx.fillStyle = '#C0C0C0';
                        ctx.beginPath();
                        ctx.arc(x + obj.width / 2, y + obj.height / 2, obj.width / 2, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 'wool':
                        ctx.fillStyle = '#FFFFFF';
                        ctx.beginPath();
                        ctx.arc(x + obj.width / 2, y + obj.height / 2, obj.width / 2, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 'finish':
                        ctx.fillStyle = '#00FF00';
                        ctx.fillRect(x, y, obj.width, obj.height);
                        break;
                }
            });

            particles.forEach(p => {
                ctx.fillStyle = `rgba(${parseInt(p.color.slice(1, 3), 16)}, ${parseInt(p.color.slice(3, 5), 16)}, ${parseInt(p.color.slice(5, 7), 16)}, ${p.alpha})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size / 2, 0, Math.PI * 2);
                ctx.fill();
            });

            if (currentCharacter.isImage && sheepImage) {
                ctx.drawImage(sheepImage, player.x, player.y, player.width, player.height);
            } else {
                ctx.fillStyle = currentCharacter.color;
                ctx.fillRect(player.x, player.y, player.width, player.height);
            }

            ctx.fillStyle = 'black';
            ctx.font = '16px Arial';
            const currentTime = gameRunning ? (performance.now() - gameStartTime) / 1000 : 0;
            ctx.fillText(`Nivel: ${levels[currentLevel].name}`, 10, 20);
            ctx.fillText(`Tiempo: ${currentTime.toFixed(1)}s`, 10, 40);
            ctx.fillText(`Monedas: ${coins}`, 10, 60);
            const progress = Math.min(100, (scrollPosition / (90 * scrollSpeed * 60)) * 100);
            ctx.fillText(`Progreso: ${progress.toFixed(0)}%`, canvas.width - 100, 20);
        }

        let isHolding = false;
        let jumpStartTime = 0;

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && gameRunning && !isPaused) {
                if (!player.jumping) {
                    isHolding = true;
                    jumpStartTime = performance.now();
                    player.vy = jumpStrength;
                    player.jumping = true;
                }
            } else if (e.code === 'Escape' && gameRunning) {
                togglePause();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                isHolding = false;
            }
        });

        canvas.addEventListener('mousedown', () => {
            if (gameRunning && !isPaused && !player.jumping) {
                isHolding = true;
                jumpStartTime = performance.now();
                player.vy = jumpStrength;
                player.jumping = true;
            }
        });

        canvas.addEventListener('mouseup', () => {
            isHolding = false;
        });

        pauseButton.addEventListener('click', togglePause);

        function updateJump() {
            if (isHolding && player.jumping) {
                const holdTime = performance.now() - jumpStartTime;
                if (holdTime < player.maxJumpHold) {
                    player.vy -= 0.15;
                }
            }
        }

        function handleDeath() {
            playAudio(deathSoundBuffer);
            createParticles(player.x + player.width / 2, player.y + player.height / 2, 10, '#FF0000');
            stopAudio();
            objects = [];
            scrollPosition = 0;
            player.x = 100;
            player.y = 300;
            player.vy = 0;
            player.jumping = false;
            practiceStartTime = practiceMode ? practiceStartTime : 0;
            audioSource = playAudio(audioBuffer);
            audioStartTime = audioContext.currentTime - practiceStartTime;
            gameStartTime = performance.now();
        }

        function togglePause() {
            isPaused = !isPaused;
            pauseMenu.style.display = isPaused ? 'block' : 'none';
            pauseButton.style.display = isPaused ? 'none' : 'block';
            if (!isPaused) {
                audioSource = playAudio(audioBuffer);
                audioStartTime = audioContext.currentTime - (audioBuffer ? audioContext.currentTime - audioStartTime : 0);
                requestAnimationFrame(gameLoop);
            } else {
                stopAudio();
            }
        }

        function startGame(level, startTime = 0) {
            console.log(`Starting level ${level} at time ${startTime}`);
            currentLevel = level;
            scrollPosition = 0;
            scrollSpeed = levels[level].scrollSpeed;
            objects = [];
            terrain = levels[level].terrain;
            player.x = 100;
            player.y = 300;
            player.vy = 0;
            player.jumping = false;
            practiceMode = startTime > 0;
            practiceStartTime = startTime;
            gameStartTime = performance.now();
            menu.style.display = 'none';
            levelSelect.style.display = 'none';
            pauseMenu.style.display = 'none';
            characterMenu.style.display = 'none';
            levelComplete.style.display = 'none';
            pauseButton.style.display = 'block';
            isPaused = false;
            gameRunning = true;
            loadAssets().then(() => {
                audioSource = playAudio(audioBuffer);
                audioStartTime = audioContext.currentTime - startTime;
                requestAnimationFrame(gameLoop);
            }).catch(error => {
                console.error('Asset load failed, starting anyway:', error);
                requestAnimationFrame(gameLoop);
            });
        }

        function resumeGame() {
            togglePause();
        }

        function returnToMenu() {
            gameRunning = false;
            isPaused = false;
            stopAudio();
            menu.style.display = 'block';
            levelSelect.style.display = 'none';
            pauseMenu.style.display = 'none';
            characterMenu.style.display = 'none';
            levelComplete.style.display = 'none';
            pauseButton.style.display = 'none';
            const practiceDiv = document.querySelector('div[style*="position: absolute"]');
            if (practiceDiv) practiceDiv.remove();
        }

        function showLevelSelect() {
            menu.style.display = 'none';
            levelSelect.style.display = 'block';
            const levelList = document.getElementById('levelList');
            levelList.innerHTML = '';
            for (let level in levels) {
                const div = document.createElement('div');
                const preview = document.createElement('div');
                preview.className = 'level-preview';
                preview.style.background = levels[level].previewColor;
                const button = document.createElement('button');
                button.textContent = levels[level].name;
                button.onclick = () => startGame(parseInt(level));
                div.appendChild(preview);
                div.appendChild(button);
                levelList.appendChild(div);
            }
        }

        function togglePractice() {
            isPaused = true;
            pauseMenu.style.display = 'none';
            const practiceDiv = document.createElement('div');
            let practiceMenu = '';
            levels[currentLevel].practicePoints.forEach((practiceTime, index) => {
                practiceMenu += `<button onclick="startGame(${currentLevel}, ${practiceTime})">Sección de Práctica ${index + 1} (Iniciar en ${practiceTime.toFixed(1)}s)</button><br>`;
            });
            practiceMenu += `<button onclick="returnToMenu()">Cancelar</button>`;
            practiceDiv.innerHTML = `<h2>Modo Práctica</h2>${practiceMenu}`;
            practiceDiv.style = 'position: absolute; background: rgba(255, 255, 255, 0.9); padding: 20px; text-align: center; border-radius: 10px;';
            document.body.appendChild(practiceDiv);
            menu.style.display = 'none';
            characterMenu.style.display = 'none';
            pauseButton.style.display = 'none';
        }

        function showCharacters() {
            menu.style.display = 'none';
            pauseMenu.style.display = 'none';
            levelSelect.style.display = 'none';
            characterMenu.style.display = 'block';
            const characterList = document.getElementById('characterList');
            characterList.innerHTML = '';
            characters.forEach(char => {
                const button = document.createElement('button');
                button.textContent = char.unlocked ? `Seleccionar ${char.name}` : `Desbloquear ${char.name} (${char.cost} monedas)`;
                button.disabled = !char.unlocked && coins < char.cost;
                button.onclick = () => {
                    if (!char.unlocked && coins >= char.cost) {
                        coins -= char.cost;
                        localStorage.setItem('coins', coins);
                        char.unlocked = true;
                        const unlocked = characters.filter(c => c.unlocked).map(c => c.name);
                        localStorage.setItem('characters', JSON.stringify(unlocked));
                        coinDisplays.forEach(display => display.textContent = coins);
                        showCharacters();
                    } else if (char.unlocked) {
                        currentCharacter = char;
                        returnToMenu();
                    }
                };
                characterList.appendChild(button);
            });
        }

        console.log('Script initialized');
        menu.style.display = 'block';
    </script>
</body>
</html>
